This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
apps/
  api/
    migrations/
      0001_phase1_store_discovery.sql
      0002_phase1_seed_stores.sql
      0003_phase2_product_identity.sql
      0004_phase2_seed_products.sql
      0005_phase3_cart.sql
      0006_phase4_pricing.sql
      0007_phase4_seed_prices.sql
      0008_phase5_kroger_live_prices.sql
    src/
      lib/
        cache.ts
        circuitBreaker.ts
        geo.ts
        hash.ts
        rateLimit.test.ts
        rateLimit.ts
        time.ts
      middleware/
        cors.ts
        security.ts
      providers/
        __fixtures__/
          kroger_locations_found.json
          kroger_product_details_found.json
          off_lookup_found.json
          off_lookup_not_found.json
          off_schema_drift.json
          off_search_found.json
        kroger.contract.test.ts
        kroger.ts
        nominatim.ts
        openFoodFacts.contract.test.ts
        openFoodFacts.ts
        overpass.ts
      services/
        cart.ts
        krogerLivePrices.ts
        pricing.test.ts
        pricing.ts
        productCatalog.ts
        productSearch.ts
        storeDiscovery.ts
      types/
        cloudflare-runtime.d.ts
        pricecart-shared.d.ts
      App.css
      App.tsx
      env.ts
      index.css
      index.ts
      main.tsx
      vite-env.d.ts
    worker/
      index.ts
    eslint.config.js
    index.html
    README.md
    tsconfig.app.json
    tsconfig.client.json
    tsconfig.json
    tsconfig.node.json
    tsconfig.worker.json
    vite.config.ts
    wrangler.jsonc
    wrangler.toml
  web/
    src/
      lib/
        api.ts
        cart.ts
        cartReducer.test.ts
        cartReducer.ts
        session.ts
      App.css
      App.tsx
      index.css
      main.tsx
    .env.example
    .gitignore
    eslint.config.js
    index.html
    package.json
    README.md
    tsconfig.app.json
    tsconfig.json
    tsconfig.node.json
    vite.config.ts
packages/
  shared/
    src/
      cart.ts
      index.ts
      pricing.ts
      product.ts
      store.ts
    package.json
    tsconfig.json
.gitignore
.repomixignore
package.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="apps/api/migrations/0001_phase1_store_discovery.sql">
CREATE TABLE IF NOT EXISTS query_cache (
  cache_key TEXT PRIMARY KEY,
  payload_json TEXT NOT NULL,
  created_at INTEGER NOT NULL,
  expires_at INTEGER NOT NULL
);
CREATE INDEX IF NOT EXISTS idx_query_cache_expires ON query_cache(expires_at);

-- Per-session token buckets for provider guardrails
CREATE TABLE IF NOT EXISTS rate_limits (
  rl_key TEXT PRIMARY KEY,
  tokens REAL NOT NULL,
  updated_at INTEGER NOT NULL
);

-- Provider circuit breaker state
CREATE TABLE IF NOT EXISTS provider_health (
  provider TEXT PRIMARY KEY,
  consecutive_failures INTEGER NOT NULL,
  open_until INTEGER NOT NULL
);

-- Stores table (seed + OSM)
CREATE TABLE IF NOT EXISTS stores (
  id TEXT PRIMARY KEY,
  source TEXT NOT NULL,              -- osm | seed
  external_id TEXT,                  -- e.g., osm:node/123
  name TEXT NOT NULL,
  lat REAL NOT NULL,
  lon REAL NOT NULL,
  tags_json TEXT,
  last_seen_at INTEGER NOT NULL
);
CREATE UNIQUE INDEX IF NOT EXISTS idx_stores_source_external
  ON stores(source, external_id);

-- Seed data marker
CREATE TABLE IF NOT EXISTS seed_meta (
  k TEXT PRIMARY KEY,
  v TEXT NOT NULL
);
</file>

<file path="apps/api/migrations/0002_phase1_seed_stores.sql">
INSERT OR REPLACE INTO seed_meta (k, v) VALUES ('seed_version', 'phase1-v1');

-- Seed stores (example: Manhattan-ish). Replace/expand as desired.
INSERT OR REPLACE INTO stores (id, source, external_id, name, lat, lon, tags_json, last_seen_at) VALUES
('seed-1', 'seed', NULL, 'Seed Market A', 40.748400, -73.985700, '{"shop":"supermarket"}', strftime('%s','now')),
('seed-2', 'seed', NULL, 'Seed Grocery B', 40.742000, -73.992000, '{"shop":"supermarket"}', strftime('%s','now')),
('seed-3', 'seed', NULL, 'Seed Convenience C', 40.754000, -73.977500, '{"shop":"convenience"}', strftime('%s','now'));
</file>

<file path="apps/api/migrations/0003_phase2_product_identity.sql">
-- Phase 2: product identity (Open Food Facts)

CREATE TABLE IF NOT EXISTS products (
  upc TEXT PRIMARY KEY,
  source TEXT NOT NULL,              -- openfoodfacts | seed
  off_product_id TEXT,
  name TEXT NOT NULL,
  brand TEXT,
  quantity_value REAL,
  quantity_unit TEXT,
  normalized_name TEXT NOT NULL,
  image_url TEXT,
  source_url TEXT,
  updated_at INTEGER NOT NULL,
  raw_hash TEXT
);

CREATE INDEX IF NOT EXISTS idx_products_normalized_name
  ON products(normalized_name);

-- Optional: store raw payload + hash for drift detection
CREATE TABLE IF NOT EXISTS product_provider_payloads (
  provider TEXT NOT NULL,
  upc TEXT NOT NULL,
  raw_json TEXT NOT NULL,
  raw_hash TEXT NOT NULL,
  fetched_at INTEGER NOT NULL,
  PRIMARY KEY (provider, upc)
);
</file>

<file path="apps/api/migrations/0005_phase3_cart.sql">
-- Phase 3: server-backed cart (anonymous session)

CREATE TABLE IF NOT EXISTS carts (
  session_id TEXT PRIMARY KEY,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL
);

CREATE TABLE IF NOT EXISTS cart_items (
  session_id TEXT NOT NULL,
  upc TEXT NOT NULL,
  quantity INTEGER NOT NULL,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  PRIMARY KEY (session_id, upc)
);

CREATE INDEX IF NOT EXISTS idx_cart_items_session
  ON cart_items(session_id);
</file>

<file path="apps/api/migrations/0006_phase4_pricing.sql">
-- Phase 4: pricing snapshots (Open Prices + community)

CREATE TABLE IF NOT EXISTS price_snapshots (
  id TEXT PRIMARY KEY,
  store_id TEXT NOT NULL,
  upc TEXT NOT NULL,

  price_cents INTEGER NOT NULL,
  currency TEXT NOT NULL,

  observed_at INTEGER NOT NULL,   -- when the price was observed
  source TEXT NOT NULL,           -- open_prices | community | kroger
  evidence_type TEXT NOT NULL,    -- dataset | manual | receipt_text

  confidence REAL NOT NULL,       -- 0.0 - 1.0 (simple, explainable)
  submitter_session_id TEXT,      -- only for community submissions (anonymous)

  flags_json TEXT,                -- optional moderation/outlier info
  created_at INTEGER NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_price_snapshots_store_upc_observed
  ON price_snapshots(store_id, upc, observed_at DESC);

CREATE INDEX IF NOT EXISTS idx_price_snapshots_upc_observed
  ON price_snapshots(upc, observed_at DESC);

CREATE INDEX IF NOT EXISTS idx_price_snapshots_source_observed
  ON price_snapshots(source, observed_at DESC);
</file>

<file path="apps/api/migrations/0007_phase4_seed_prices.sql">
-- Phase 4 seed pricing for demo + tests

-- Use the same seed stores from 0002 and seed products from 0004
-- UPCs:
-- 0000000000001 Seed Whole Milk
-- 0000000000002 Seed Peanut Butter
-- 012345678905  Seed Honeycrisp Apples

-- Store A (seed-1): cheapest overall
INSERT OR REPLACE INTO price_snapshots (
  id, store_id, upc, price_cents, currency, observed_at, source, evidence_type,
  confidence, submitter_session_id, flags_json, created_at
) VALUES
(
  'op-seed-1-milk', 'seed-1', '0000000000001', 399, 'USD', strftime('%s','now') - 86400,
  'open_prices', 'dataset', 0.75, NULL, NULL, strftime('%s','now')
),
(
  'op-seed-1-pb', 'seed-1', '0000000000002', 549, 'USD', strftime('%s','now') - 172800,
  'open_prices', 'dataset', 0.75, NULL, NULL, strftime('%s','now')
),
(
  'op-seed-1-apples', 'seed-1', '012345678905', 699, 'USD', strftime('%s','now') - 259200,
  'open_prices', 'dataset', 0.75, NULL, NULL, strftime('%s','now')
);

-- Store B (seed-2): slightly more expensive
INSERT OR REPLACE INTO price_snapshots (
  id, store_id, upc, price_cents, currency, observed_at, source, evidence_type,
  confidence, submitter_session_id, flags_json, created_at
) VALUES
(
  'op-seed-2-milk', 'seed-2', '0000000000001', 429, 'USD', strftime('%s','now') - 86400,
  'open_prices', 'dataset', 0.75, NULL, NULL, strftime('%s','now')
),
(
  'op-seed-2-pb', 'seed-2', '0000000000002', 599, 'USD', strftime('%s','now') - 172800,
  'open_prices', 'dataset', 0.75, NULL, NULL, strftime('%s','now')
),
(
  'op-seed-2-apples', 'seed-2', '012345678905', 749, 'USD', strftime('%s','now') - 259200,
  'open_prices', 'dataset', 0.75, NULL, NULL, strftime('%s','now')
);

-- Store C (seed-3): missing apples initially (forces missing-item behavior)
INSERT OR REPLACE INTO price_snapshots (
  id, store_id, upc, price_cents, currency, observed_at, source, evidence_type,
  confidence, submitter_session_id, flags_json, created_at
) VALUES
(
  'op-seed-3-milk', 'seed-3', '0000000000001', 409, 'USD', strftime('%s','now') - 86400,
  'open_prices', 'dataset', 0.75, NULL, NULL, strftime('%s','now')
),
(
  'op-seed-3-pb', 'seed-3', '0000000000002', 579, 'USD', strftime('%s','now') - 172800,
  'open_prices', 'dataset', 0.75, NULL, NULL, strftime('%s','now')
);

-- OPTIONAL: a seeded community submission example
INSERT OR REPLACE INTO price_snapshots (
  id, store_id, upc, price_cents, currency, observed_at, source, evidence_type,
  confidence, submitter_session_id, flags_json, created_at
) VALUES
(
  'community-seed-3-apples', 'seed-3', '012345678905', 799, 'USD', strftime('%s','now') - 43200,
  'community', 'manual', 0.45, 'seed-session', '{"note":"seeded manual price"}', strftime('%s','now')
);
</file>

<file path="apps/api/migrations/0008_phase5_kroger_live_prices.sql">
-- Phase 5: Kroger live-price support (store -> provider location mapping)

CREATE TABLE IF NOT EXISTS store_provider_mappings (
  store_id TEXT NOT NULL,
  provider TEXT NOT NULL,
  provider_location_id TEXT NOT NULL,
  match_method TEXT NOT NULL,
  match_score REAL NOT NULL,
  created_at INTEGER NOT NULL,
  verified_at INTEGER NOT NULL,
  PRIMARY KEY (store_id, provider)
);

CREATE INDEX IF NOT EXISTS idx_store_provider_mappings_provider_location
  ON store_provider_mappings(provider, provider_location_id);

CREATE INDEX IF NOT EXISTS idx_store_provider_mappings_verified
  ON store_provider_mappings(provider, verified_at);
</file>

<file path="apps/api/src/lib/cache.ts">
import { nowSec } from "./time";

export async function cacheGet<T>(db: D1Database, cacheKey: string): Promise<T | null> {
  const t = nowSec();
  const row = await db
    .prepare("SELECT payload_json, expires_at FROM query_cache WHERE cache_key = ?")
    .bind(cacheKey)
    .first<{ payload_json: string; expires_at: number }>();

  if (!row) return null;
  if (row.expires_at <= t) return null;
  return JSON.parse(row.payload_json) as T;
}

export async function cachePut<T>(
  db: D1Database,
  cacheKey: string,
  payload: T,
  ttlSec: number
): Promise<void> {
  const t = nowSec();
  const expires = t + ttlSec;
  await db
    .prepare(
      "INSERT OR REPLACE INTO query_cache (cache_key, payload_json, created_at, expires_at) VALUES (?, ?, ?, ?)"
    )
    .bind(cacheKey, JSON.stringify(payload), t, expires)
    .run();
}

export async function cachePurgeExpired(db: D1Database): Promise<void> {
  const t = nowSec();
  await db.prepare("DELETE FROM query_cache WHERE expires_at <= ?").bind(t).run();
}


export async function cachePeek<T>(
  db: D1Database,
  cacheKey: string
): Promise<{ payload: T; expires_at: number; is_fresh: boolean } | null> {
  const t = nowSec();
  const row = await db
    .prepare("SELECT payload_json, expires_at FROM query_cache WHERE cache_key = ?")
    .bind(cacheKey)
    .first<{ payload_json: string; expires_at: number }>();

  if (!row) return null;

  const payload = JSON.parse(row.payload_json) as T;
  return { payload, expires_at: row.expires_at, is_fresh: row.expires_at > t };
}
</file>

<file path="apps/api/src/lib/circuitBreaker.ts">
import { nowSec } from "./time";

type Row = { consecutive_failures: number; open_until: number };

export async function isOpen(db: D1Database, provider: string): Promise<boolean> {
  const t = nowSec();
  const row = await db
    .prepare("SELECT consecutive_failures, open_until FROM provider_health WHERE provider = ?")
    .bind(provider)
    .first<Row>();
  if (!row) return false;
  return row.open_until > t;
}

export async function recordSuccess(db: D1Database, provider: string): Promise<void> {
  await db
    .prepare(
      "INSERT OR REPLACE INTO provider_health (provider, consecutive_failures, open_until) VALUES (?, 0, 0)"
    )
    .bind(provider)
    .run();
}

export async function recordFailure(
  db: D1Database,
  provider: string,
  opts?: { tripAfter?: number; openForSec?: number }
): Promise<void> {
  const tripAfter = opts?.tripAfter ?? 3;
  const openForSec = opts?.openForSec ?? 300;

  const t = nowSec();
  const row = await db
    .prepare("SELECT consecutive_failures, open_until FROM provider_health WHERE provider = ?")
    .bind(provider)
    .first<Row>();

  const failures = (row?.consecutive_failures ?? 0) + 1;
  const openUntil = failures >= tripAfter ? t + openForSec : (row?.open_until ?? 0);

  await db
    .prepare(
      "INSERT OR REPLACE INTO provider_health (provider, consecutive_failures, open_until) VALUES (?, ?, ?)"
    )
    .bind(provider, failures, openUntil)
    .run();
}
</file>

<file path="apps/api/src/lib/geo.ts">
// Haversine distance (meters)
export function distanceMeters(a: { lat: number; lon: number }, b: { lat: number; lon: number }): number {
  const R = 6371000;
  const toRad = (d: number) => (d * Math.PI) / 180;

  const dLat = toRad(b.lat - a.lat);
  const dLon = toRad(b.lon - a.lon);
  const lat1 = toRad(a.lat);
  const lat2 = toRad(b.lat);

  const sinDLat = Math.sin(dLat / 2);
  const sinDLon = Math.sin(dLon / 2);

  const h = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon;
  return 2 * R * Math.asin(Math.sqrt(h));
}
</file>

<file path="apps/api/src/lib/hash.ts">
export async function sha256Base64Url(input: string): Promise<string> {
  const data = new TextEncoder().encode(input);
  const digest = await crypto.subtle.digest("SHA-256", data);
  const bytes = new Uint8Array(digest);
  const b64 = btoa(String.fromCharCode(...bytes));
  return b64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
}
</file>

<file path="apps/api/src/lib/rateLimit.test.ts">
import { describe, expect, it } from "vitest";
import { takeToken } from "./rateLimit";

function fakeDb(): D1Database {
  const m = new Map<string, { tokens: number; updated_at: number }>();
  return {
    prepare(sql: string) {
      return {
        bind(key: string, ...rest: unknown[]) {
          return {
            async first() {
              return m.get(key) ?? null;
            },
            async run() {
              if (sql.includes("INSERT OR REPLACE INTO rate_limits")) {
                const [tokensValue, updatedValue] = rest;
                const tokens = Number(tokensValue);
                const updated = Number(updatedValue);
                m.set(key, { tokens, updated_at: updated });
              }
              return { success: true };
            }
          };
        }
      };
    }
  } as unknown as D1Database;
}

describe("takeToken", () => {
  it("allows up to capacity then blocks", async () => {
    const db = fakeDb();
    const cfg = { capacity: 2, refillPerSec: 0, cost: 1 };

    expect(await takeToken(db, "k", cfg)).toBe(true);
    expect(await takeToken(db, "k", cfg)).toBe(true);
    expect(await takeToken(db, "k", cfg)).toBe(false);
  });
});
</file>

<file path="apps/api/src/lib/rateLimit.ts">
import { nowSec } from "./time";

export type TokenBucketConfig = {
  capacity: number;        // max tokens stored
  refillPerSec: number;    // tokens added per second
  cost: number;            // tokens consumed per operation
};

/**
 * Leaky token bucket stored in D1.
 * Returns true if allowed, false if rate-limited.
 */
export async function takeToken(
  db: D1Database,
  key: string,
  cfg: TokenBucketConfig
): Promise<boolean> {
  const t = nowSec();
  const row = await db
    .prepare("SELECT tokens, updated_at FROM rate_limits WHERE rl_key = ?")
    .bind(key)
    .first<{ tokens: number; updated_at: number }>();

  let tokens = row?.tokens ?? cfg.capacity;
  const updatedAt = row?.updated_at ?? t;
  const elapsed = Math.max(0, t - updatedAt);

  tokens = Math.min(cfg.capacity, tokens + elapsed * cfg.refillPerSec);

  const allowed = tokens >= cfg.cost;
  if (allowed) tokens -= cfg.cost;

  await db
    .prepare("INSERT OR REPLACE INTO rate_limits (rl_key, tokens, updated_at) VALUES (?, ?, ?)")
    .bind(key, tokens, t)
    .run();

  return allowed;
}
</file>

<file path="apps/api/src/lib/time.ts">
export const nowSec = () => Math.floor(Date.now() / 1000);
</file>

<file path="apps/api/src/middleware/security.ts">
import type { MiddlewareHandler } from "hono";

export function securityHeaders(): MiddlewareHandler {
  return async (c, next) => {
    await next();
    c.header("X-Content-Type-Options", "nosniff");
    c.header("X-Frame-Options", "DENY");
    c.header("Referrer-Policy", "no-referrer");
    c.header("Permissions-Policy", "geolocation=()",);
  };
}
</file>

<file path="apps/api/src/providers/__fixtures__/kroger_locations_found.json">
{
  "data": [
    {
      "locationId": "12345",
      "name": "Kroger - Demo Location",
      "chain": "Kroger",
      "geolocation": { "latitude": 40.75, "longitude": -73.99 }
    }
  ]
}
</file>

<file path="apps/api/src/providers/__fixtures__/kroger_product_details_found.json">
{
  "data": {
    "upc": "0001111041707",
    "items": [
      { "price": { "regular": 2.99, "promo": 1.99 } }
    ]
  }
}
</file>

<file path="apps/api/src/providers/__fixtures__/off_lookup_found.json">
{
  "status": 1,
  "product": {
    "code": "0123456789012",
    "product_name": "Fixture Granola Bar",
    "brands": "Fixture Brand",
    "quantity": "40 g",
    "image_front_url": "https://example.com/img.jpg",
    "url": "https://world.openfoodfacts.org/product/0123456789012",
    "last_modified_t": 1700000000
  }
}
</file>

<file path="apps/api/src/providers/__fixtures__/off_lookup_not_found.json">
{ "status": 0, "status_verbose": "product not found" }
</file>

<file path="apps/api/src/providers/__fixtures__/off_schema_drift.json">
{
  "status": 1,
  "product": {
    "code": "0123456789012",
    "product_name": "Fixture Granola Bar",
    "brands": "Fixture Brand",
    "quantity": "40 g",
    "some_new_field": { "nested": true }
  }
}
</file>

<file path="apps/api/src/providers/__fixtures__/off_search_found.json">
{
  "count": 2,
  "page": 1,
  "page_size": 10,
  "products": [
    {
      "code": "0123456789012",
      "product_name": "Fixture Granola Bar",
      "brands": "Fixture Brand",
      "quantity": "40 g",
      "url": "https://world.openfoodfacts.org/product/0123456789012"
    },
    {
      "code": "0000000000001",
      "product_name": "Fixture Milk",
      "brands": "Fixture Brand",
      "quantity": "1 L",
      "url": "https://world.openfoodfacts.org/product/0000000000001"
    }
  ]
}
</file>

<file path="apps/api/src/providers/kroger.contract.test.ts">
import { readFileSync } from "node:fs";
import { describe, expect, it } from "vitest";
import { parseKrogerLocationsResponse, parseKrogerProductDetailsResponse } from "./kroger";

function fixture(name: string) {
  return JSON.parse(readFileSync(new URL(`./__fixtures__/${name}`, import.meta.url), "utf-8"));
}

describe("Kroger provider (contract)", () => {
  it("parses locations", () => {
    const json = fixture("kroger_locations_found.json");
    const locs = parseKrogerLocationsResponse(json);
    expect(locs.length).toBeGreaterThan(0);
    expect(locs[0].locationId).toBe("12345");
    expect(typeof locs[0].lat).toBe("number");
    expect(typeof locs[0].lon).toBe("number");
  });

  it("parses product price (prefers promo)", () => {
    const json = fixture("kroger_product_details_found.json");
    const p = parseKrogerProductDetailsResponse(json, "0001111041707");
    expect(p.upc).toBe("0001111041707");
    expect(p.price_cents).toBe(199);
  });
});
</file>

<file path="apps/api/src/providers/kroger.ts">
import { z } from "zod";
import { isOpen, recordFailure, recordSuccess } from "../lib/circuitBreaker";

const PROVIDER = "kroger";

function b64(s: string) {
  const g: any = globalThis as any;
  if (typeof g.btoa === "function") return g.btoa(s);
  return Buffer.from(s, "utf8").toString("base64");
}

function toNumber(v: unknown): number | null {
  if (typeof v === "number" && Number.isFinite(v)) return v;
  if (typeof v === "string") {
    const n = Number(v);
    return Number.isFinite(n) ? n : null;
  }
  return null;
}

function toCents(v: unknown): number | null {
  const n = toNumber(v);
  if (n === null) return null;
  return Math.round(n * 100);
}

/** ---------------- Token ---------------- */
const TokenResponseSchema = z
  .object({
    access_token: z.string(),
    token_type: z.string().optional(),
    expires_in: z.union([z.number(), z.string()]).optional(),
    scope: z.string().optional()
  })
  .passthrough();

export type KrogerToken = {
  access_token: string;
  expires_in_sec: number | null;
  scope: string | null;
};

export function parseKrogerTokenResponse(json: unknown): KrogerToken {
  const r = TokenResponseSchema.parse(json);
  const exp = toNumber(r.expires_in);
  return {
    access_token: r.access_token,
    expires_in_sec: exp === null ? null : Math.floor(exp),
    scope: r.scope ?? null
  };
}

/** ---------------- Locations ---------------- */
const KrogerLocationSchema = z
  .object({
    locationId: z.string(),
    name: z.string().optional().nullable(),
    chain: z.string().optional().nullable(),
    geolocation: z
      .object({
        latitude: z.union([z.number(), z.string()]).optional(),
        longitude: z.union([z.number(), z.string()]).optional()
      })
      .optional()
      .nullable(),
    latitude: z.union([z.number(), z.string()]).optional(),
    longitude: z.union([z.number(), z.string()]).optional()
  })
  .passthrough();

const KrogerLocationsResponseSchema = z
  .object({
    data: z.array(KrogerLocationSchema).default([])
  })
  .passthrough();

export type KrogerLocation = {
  locationId: string;
  name: string | null;
  chain: string | null;
  lat: number;
  lon: number;
};

export function parseKrogerLocationsResponse(json: unknown): KrogerLocation[] {
  const r = KrogerLocationsResponseSchema.parse(json);
  const out: KrogerLocation[] = [];

  for (const loc of r.data) {
    const lat =
      toNumber(loc.geolocation?.latitude) ??
      toNumber(loc.latitude) ??
      null;
    const lon =
      toNumber(loc.geolocation?.longitude) ??
      toNumber(loc.longitude) ??
      null;

    if (lat === null || lon === null) continue;

    out.push({
      locationId: loc.locationId,
      name: loc.name ?? null,
      chain: loc.chain ?? null,
      lat,
      lon
    });
  }

  return out;
}

/** ---------------- Product details ---------------- */
const KrogerPriceSchema = z
  .object({
    regular: z.union([z.number(), z.string()]).optional(),
    promo: z.union([z.number(), z.string()]).optional()
  })
  .passthrough();

const KrogerItemSchema = z
  .object({
    price: KrogerPriceSchema.optional().nullable()
  })
  .passthrough();

const KrogerProductSchema = z
  .object({
    upc: z.string().optional(),
    items: z.array(KrogerItemSchema).optional().nullable()
  })
  .passthrough();

const KrogerProductDetailsResponseSchema = z
  .object({
    data: z.union([KrogerProductSchema, z.array(KrogerProductSchema)]).optional()
  })
  .passthrough();

export type KrogerProductPrice = {
  upc: string;
  price_cents: number | null;
};

export function parseKrogerProductDetailsResponse(json: unknown, upcFallback: string): KrogerProductPrice {
  const r = KrogerProductDetailsResponseSchema.parse(json);
  const data = Array.isArray(r.data) ? r.data[0] : r.data;
  if (!data) return { upc: upcFallback, price_cents: null };

  const upc = data.upc ?? upcFallback;
  const item = data.items?.[0];
  const price = item?.price ?? null;

  const promo = price ? toCents(price.promo) : null;
  const regular = price ? toCents(price.regular) : null;

  return { upc, price_cents: promo ?? regular ?? null };
}

/** ---------------- HTTP calls (with circuit breaker) ---------------- */
export async function fetchKrogerToken(
  db: D1Database,
  opts: {
    client_id: string;
    client_secret: string;
    token_url?: string;
    scope?: string;
    user_agent?: string;
    referer?: string;
  }
): Promise<KrogerToken> {
  if (await isOpen(db, PROVIDER)) throw new Error("KROGER_CIRCUIT_OPEN");

  const tokenUrl = opts.token_url ?? "https://api.kroger.com/v1/connect/oauth2/token";
  const scope = opts.scope ?? "product.compact";
  const auth = b64(`${opts.client_id}:${opts.client_secret}`);

  try {
    const res = await fetch(tokenUrl, {
      method: "POST",
      headers: {
        Authorization: `Basic ${auth}`,
        "Content-Type": "application/x-www-form-urlencoded",
        ...(opts.user_agent ? { "User-Agent": opts.user_agent } : {}),
        ...(opts.referer ? { Referer: opts.referer } : {})
      },
      body: new URLSearchParams({
        grant_type: "client_credentials",
        scope
      }).toString()
    });

    const text = await res.text();
    if (!res.ok) throw new Error(`KROGER_TOKEN_HTTP_${res.status}: ${text.slice(0, 300)}`);

    const json = JSON.parse(text);
    const parsed = parseKrogerTokenResponse(json);
    await recordSuccess(db, PROVIDER);
    return parsed;
  } catch (e) {
    await recordFailure(db, PROVIDER);
    throw e;
  }
}

export async function fetchKrogerLocations(
  db: D1Database,
  opts: {
    access_token: string;
    base_url?: string;
    lat: number;
    lon: number;
    radius_miles?: number;
    limit?: number;
    user_agent?: string;
    referer?: string;
  }
): Promise<KrogerLocation[]> {
  if (await isOpen(db, PROVIDER)) throw new Error("KROGER_CIRCUIT_OPEN");

  const baseUrl = opts.base_url ?? "https://api.kroger.com/v1";
  const radius = opts.radius_miles ?? 2;
  const limit = opts.limit ?? 10;

  const url = new URL(`${baseUrl}/locations`);
  url.searchParams.set("filter.latLong.near", `${opts.lat},${opts.lon}`);
  url.searchParams.set("filter.radiusInMiles", String(radius));
  url.searchParams.set("filter.limit", String(limit));

  try {
    const res = await fetch(url.toString(), {
      headers: {
        Authorization: `Bearer ${opts.access_token}`,
        Accept: "application/json",
        ...(opts.user_agent ? { "User-Agent": opts.user_agent } : {}),
        ...(opts.referer ? { Referer: opts.referer } : {})
      }
    });

    const text = await res.text();
    if (!res.ok) throw new Error(`KROGER_LOCATIONS_HTTP_${res.status}: ${text.slice(0, 300)}`);

    const json = JSON.parse(text);
    const parsed = parseKrogerLocationsResponse(json);
    await recordSuccess(db, PROVIDER);
    return parsed;
  } catch (e) {
    await recordFailure(db, PROVIDER);
    throw e;
  }
}

export async function fetchKrogerProductDetails(
  db: D1Database,
  opts: {
    access_token: string;
    base_url?: string;
    location_id: string;
    upc: string;
    user_agent?: string;
    referer?: string;
  }
): Promise<KrogerProductPrice> {
  if (await isOpen(db, PROVIDER)) throw new Error("KROGER_CIRCUIT_OPEN");

  const baseUrl = opts.base_url ?? "https://api.kroger.com/v1";
  const url = new URL(`${baseUrl}/products/${encodeURIComponent(opts.upc)}`);
  url.searchParams.set("filter.locationId", opts.location_id);

  try {
    const res = await fetch(url.toString(), {
      headers: {
        Authorization: `Bearer ${opts.access_token}`,
        Accept: "application/json",
        ...(opts.user_agent ? { "User-Agent": opts.user_agent } : {}),
        ...(opts.referer ? { Referer: opts.referer } : {})
      }
    });

    const text = await res.text();
    if (!res.ok) throw new Error(`KROGER_PRODUCT_HTTP_${res.status}: ${text.slice(0, 300)}`);

    const json = JSON.parse(text);
    const parsed = parseKrogerProductDetailsResponse(json, opts.upc);
    await recordSuccess(db, PROVIDER);
    return parsed;
  } catch (e) {
    await recordFailure(db, PROVIDER);
    throw e;
  }
}
</file>

<file path="apps/api/src/providers/nominatim.ts">
import { isOpen, recordFailure, recordSuccess } from "../lib/circuitBreaker";

export type GeocodeResult = { lat: number; lon: number; display_name?: string };

export async function geocode(
  env: { DB: D1Database; OUTBOUND_USER_AGENT?: string; OUTBOUND_REFERER?: string },
  location: string
): Promise<GeocodeResult> {
  const provider = "nominatim";
  if (await isOpen(env.DB, provider)) throw new Error("PROVIDER_OPEN");

  const url = new URL("https://nominatim.openstreetmap.org/search");
  url.searchParams.set("q", location);
  url.searchParams.set("format", "json");
  url.searchParams.set("limit", "1");

  const headers: Record<string, string> = {
    Accept: "application/json",
    "User-Agent": env.OUTBOUND_USER_AGENT || "PriceCart/0.1 (contact: you@example.com)",
    Referer: env.OUTBOUND_REFERER || "https://example.com"
  };

  try {
    const res = await fetch(url.toString(), { headers });
    if (!res.ok) {
      await recordFailure(env.DB, provider);
      throw new Error(`Nominatim HTTP ${res.status}`);
    }

    const json = (await res.json()) as Array<{ lat: string; lon: string; display_name?: string }>;
    if (!json[0]) {
      await recordSuccess(env.DB, provider);
      throw new Error("NOT_FOUND");
    }

    await recordSuccess(env.DB, provider);
    return { lat: Number(json[0].lat), lon: Number(json[0].lon), display_name: json[0].display_name };
  } catch (e) {
    await recordFailure(env.DB, provider);
    throw e;
  }
}
</file>

<file path="apps/api/src/providers/openFoodFacts.contract.test.ts">
import { describe, expect, it } from "vitest";
import { parseOffLookupResponse, parseOffSearchResponse } from "./openFoodFacts";

import { readFileSync } from "node:fs";

function loadFixture(path: string) {
  const p = new URL(path, import.meta.url);
  return JSON.parse(readFileSync(p, "utf-8"));
}

describe("OpenFoodFacts provider parsing", () => {
  it("parses lookup happy path", async () => {
    const json = await loadFixture("./__fixtures__/off_lookup_found.json");
    const p = parseOffLookupResponse(json, "0123456789012");
    expect(p.code).toBe("0123456789012");
    expect(p.product_name).toMatch(/Fixture/);
  });

  it("lookup not found maps to NOT_FOUND", async () => {
    const json = await loadFixture("./__fixtures__/off_lookup_not_found.json");
    expect(() => parseOffLookupResponse(json, "0123456789012")).toThrow(/NOT_FOUND/);
  });

  it("parses search response", async () => {
    const json = await loadFixture("./__fixtures__/off_search_found.json");
    const r = parseOffSearchResponse(json);
    expect(r.products.length).toBeGreaterThan(0);
  });

  it("tolerates schema drift", async () => {
    const json = await loadFixture("./__fixtures__/off_schema_drift.json");
    const p = parseOffLookupResponse(json, "0123456789012");
    expect(p.code).toBe("0123456789012");
  });
});
</file>

<file path="apps/api/src/providers/openFoodFacts.ts">
import { z } from "zod";
import { isOpen, recordFailure, recordSuccess } from "../lib/circuitBreaker";

export const OFF_ATTRIBUTION = {
  text: "Data from Open Food Facts",
  links: [
    { label: "Open Food Facts", href: "https://world.openfoodfacts.org" },
    { label: "API", href: "https://openfoodfacts.github.io/openfoodfacts-server/api/" }
  ]
};

export type OffProductRaw = {
  code: string;
  product_name: string | null;
  brands: string | null;
  quantity: string | null;
  image_front_url: string | null;
  url: string | null;
  last_modified_t: number | null;
};

const OffProductSchema = z
  .object({
    code: z.string().optional(),
    product_name: z.string().optional(),
    brands: z.string().optional(),
    quantity: z.string().optional(),
    image_front_url: z.string().url().optional(),
    url: z.string().url().optional(),
    last_modified_t: z.number().optional()
  })
  .passthrough();

const OffLookupSchema = z
  .object({
    status: z.number(),
    status_verbose: z.string().optional(),
    product: OffProductSchema.optional()
  })
  .passthrough();

const OffSearchSchema = z
  .object({
    count: z.number().optional(),
    page: z.number().optional(),
    page_size: z.number().optional(),
    products: z.array(OffProductSchema).default([])
  })
  .passthrough();

export function parseOffLookupResponse(json: unknown, upc: string): OffProductRaw {
  const parsed = OffLookupSchema.safeParse(json);
  if (!parsed.success) throw new Error("OFF_SCHEMA");

  if (parsed.data.status !== 1 || !parsed.data.product) throw new Error("NOT_FOUND");

  const p = parsed.data.product;
  return {
    code: String(p.code ?? upc),
    product_name: p.product_name ?? null,
    brands: p.brands ?? null,
    quantity: p.quantity ?? null,
    image_front_url: p.image_front_url ?? null,
    url: p.url ?? null,
    last_modified_t: p.last_modified_t ?? null
  };
}

export function parseOffSearchResponse(json: unknown): {
  total: number;
  page: number;
  page_size: number;
  products: OffProductRaw[];
} {
  const parsed = OffSearchSchema.safeParse(json);
  if (!parsed.success) throw new Error("OFF_SCHEMA");

  const total = parsed.data.count ?? parsed.data.products.length;
  const page = parsed.data.page ?? 1;
  const page_size = parsed.data.page_size ?? parsed.data.products.length;

  const products: OffProductRaw[] = parsed.data.products.map((p) => ({
    code: String(p.code ?? ""),
    product_name: p.product_name ?? null,
    brands: p.brands ?? null,
    quantity: p.quantity ?? null,
    image_front_url: p.image_front_url ?? null,
    url: p.url ?? null,
    last_modified_t: p.last_modified_t ?? null
  }));

  return { total, page, page_size, products };
}

function buildHeaders(env: { OUTBOUND_USER_AGENT?: string; OUTBOUND_REFERER?: string }): Record<string, string> {
  return {
    Accept: "application/json",
    "User-Agent": env.OUTBOUND_USER_AGENT || "PriceCart/0.1 (contact: you@example.com)",
    Referer: env.OUTBOUND_REFERER || "https://example.com"
  };
}

async function fetchJson(url: string, headers: Record<string, string>, timeoutMs: number) {
  const ctrl = new AbortController();
  const id = setTimeout(() => ctrl.abort(), timeoutMs);
  try {
    const res = await fetch(url, { headers, signal: ctrl.signal });
    return { res, json: await res.json().catch(() => null) };
  } finally {
    clearTimeout(id);
  }
}

export async function offLookupByUpc(
  env: { DB: D1Database; OUTBOUND_USER_AGENT?: string; OUTBOUND_REFERER?: string; OFF_BASE_URL?: string },
  upc: string
): Promise<OffProductRaw> {
  const provider = "openfoodfacts";
  if (await isOpen(env.DB, provider)) throw new Error("PROVIDER_OPEN");

  const base = env.OFF_BASE_URL || "https://world.openfoodfacts.org";
  const url = new URL(`${base}/api/v2/product/${encodeURIComponent(upc)}.json`);
  url.searchParams.set("fields", "code,product_name,brands,quantity,image_front_url,url,last_modified_t");

  try {
    const { res, json } = await fetchJson(url.toString(), buildHeaders(env), 8000);
    if (!res.ok) {
      await recordFailure(env.DB, provider);
      throw new Error(`OFF_HTTP_${res.status}`);
    }

    const product = parseOffLookupResponse(json, upc);
    await recordSuccess(env.DB, provider);
    return product;
  } catch (e) {
    await recordFailure(env.DB, provider);
    throw e;
  }
}

export async function offSearch(
  env: { DB: D1Database; OUTBOUND_USER_AGENT?: string; OUTBOUND_REFERER?: string; OFF_BASE_URL?: string },
  q: string,
  page: number,
  pageSize: number
): Promise<{ total: number; page: number; page_size: number; products: OffProductRaw[] }> {
  const provider = "openfoodfacts";
  if (await isOpen(env.DB, provider)) throw new Error("PROVIDER_OPEN");

  const base = env.OFF_BASE_URL || "https://world.openfoodfacts.org";
  const url = new URL(`${base}/api/v2/search`);
  url.searchParams.set("search_terms", q);
  url.searchParams.set("page", String(page));
  url.searchParams.set("page_size", String(pageSize));
  url.searchParams.set("fields", "code,product_name,brands,quantity,image_front_url,url,last_modified_t");

  try {
    const { res, json } = await fetchJson(url.toString(), buildHeaders(env), 9000);
    if (!res.ok) {
      await recordFailure(env.DB, provider);
      throw new Error(`OFF_HTTP_${res.status}`);
    }

    const parsed = parseOffSearchResponse(json);
    await recordSuccess(env.DB, provider);
    return { total: parsed.total, page: parsed.page, page_size: parsed.page_size, products: parsed.products };
  } catch (e) {
    await recordFailure(env.DB, provider);
    throw e;
  }
}
</file>

<file path="apps/api/src/providers/overpass.ts">
import { isOpen, recordFailure, recordSuccess } from "../lib/circuitBreaker";

export type OverpassStore = {
  external_id: string; // osm:node/123
  name: string;
  lat: number;
  lon: number;
  tags: Record<string, string>;
};

export async function queryNearbyStores(
  env: { DB: D1Database; OUTBOUND_USER_AGENT?: string; OUTBOUND_REFERER?: string },
  center: { lat: number; lon: number },
  radiusM: number
): Promise<OverpassStore[]> {
  const provider = "overpass";
  if (await isOpen(env.DB, provider)) throw new Error("PROVIDER_OPEN");

  const query = `
[out:json][timeout:25];
(
  node[shop=supermarket](around:${radiusM},${center.lat},${center.lon});
  node[shop=convenience](around:${radiusM},${center.lat},${center.lon});
  node[shop=greengrocer](around:${radiusM},${center.lat},${center.lon});
);
out body;
`;

  const headers: Record<string, string> = {
    "Content-Type": "application/x-www-form-urlencoded",
    Accept: "application/json",
    "User-Agent": env.OUTBOUND_USER_AGENT || "PriceCart/0.1 (contact: you@example.com)",
    Referer: env.OUTBOUND_REFERER || "https://example.com"
  };

  try {
    const res = await fetch("https://overpass-api.de/api/interpreter", {
      method: "POST",
      headers,
      body: new URLSearchParams({ data: query }).toString()
    });

    if (!res.ok) {
      await recordFailure(env.DB, provider);
      throw new Error(`Overpass HTTP ${res.status}`);
    }

    const json = (await res.json()) as {
      elements: Array<{ type: string; id: number; lat: number; lon: number; tags?: Record<string, string> }>;
    };

    const stores: OverpassStore[] = (json.elements || [])
      .filter((e) => e.type === "node")
      .map((e) => {
        const tags = e.tags || {};
        const name = tags.name || tags.brand || "Unnamed store";
        return {
          external_id: `osm:${e.type}/${e.id}`,
          name,
          lat: e.lat,
          lon: e.lon,
          tags
        };
      });

    await recordSuccess(env.DB, provider);
    return stores;
  } catch (e) {
    await recordFailure(env.DB, provider);
    throw e;
  }
}
</file>

<file path="apps/api/src/services/cart.ts">
import type { Cart, CartLine } from "@pricecart/shared";
import { takeToken } from "../lib/rateLimit";
import { nowSec } from "../lib/time";

const CART_MAX_ITEMS = 100;
const CART_MAX_QTY = 99;

// Write budgets (per session) - demo-friendly and abuse-resistant
const RL_CART_WRITE = { capacity: 30, refillPerSec: 1 / 2, cost: 1 }; // ~30/min

type EnvLike = { DB: D1Database };

type ProductJoinRow = {
  upc: string;
  quantity: number;
  name: string | null;
  brand: string | null;
  quantity_value: number | null;
  quantity_unit: string | null;
  image_url: string | null;
  updated_at: number;
};

function toCartLine(r: ProductJoinRow): CartLine {
  return {
    upc: r.upc,
    name: r.name ?? "Unknown product",
    brand: r.brand ?? null,
    quantity: { raw: null, value: r.quantity_value ?? null, unit: r.quantity_unit ?? null },
    image_url: r.image_url ?? null,
    count: r.quantity
  };
}

async function ensureCart(env: EnvLike, session_id: string): Promise<void> {
  const t = nowSec();
  await env.DB.prepare(
    "INSERT OR IGNORE INTO carts (session_id, created_at, updated_at) VALUES (?, ?, ?)"
  )
    .bind(session_id, t, t)
    .run();
}

async function touchCart(env: EnvLike, session_id: string): Promise<void> {
  const t = nowSec();
  await env.DB.prepare("UPDATE carts SET updated_at = ? WHERE session_id = ?")
    .bind(t, session_id)
    .run();
}

export async function getCart(env: EnvLike, session_id: string): Promise<Cart> {
  await ensureCart(env, session_id);

  const rows = await env.DB.prepare(
    `SELECT
      ci.upc as upc,
      ci.quantity as quantity,
      p.name as name,
      p.brand as brand,
      p.quantity_value as quantity_value,
      p.quantity_unit as quantity_unit,
      p.image_url as image_url,
      ci.updated_at as updated_at
     FROM cart_items ci
     LEFT JOIN products p ON p.upc = ci.upc
     WHERE ci.session_id = ?
     ORDER BY ci.updated_at DESC`
  )
    .bind(session_id)
    .all<ProductJoinRow>();

  const items = rows.results.map(toCartLine);
  const item_count = items.length;
  const total_units = items.reduce((sum, it) => sum + it.count, 0);

  const meta = await env.DB.prepare("SELECT updated_at FROM carts WHERE session_id = ?")
    .bind(session_id)
    .first<{ updated_at: number }>();

  return {
    session_id,
    updated_at: meta?.updated_at ?? nowSec(),
    item_count,
    total_units,
    items
  };
}

export async function addCartItem(
  env: EnvLike,
  input: { session_id: string; upc: string; quantity: number }
): Promise<Cart> {
  await ensureCart(env, input.session_id);

  const ok = await takeToken(env.DB, `cart_write:${input.session_id}`, RL_CART_WRITE);
  if (!ok) throw new Error("RATE_LIMITED");

  if (input.quantity > CART_MAX_QTY) throw new Error("QUANTITY_TOO_LARGE");

  // Ensure product exists (cart is built from resolved products)
  const prod = await env.DB.prepare("SELECT upc FROM products WHERE upc = ?")
    .bind(input.upc)
    .first<{ upc: string }>();
  if (!prod) throw new Error("PRODUCT_NOT_FOUND");

  const t = nowSec();
  const existing = await env.DB.prepare(
    "SELECT quantity FROM cart_items WHERE session_id = ? AND upc = ?"
  )
    .bind(input.session_id, input.upc)
    .first<{ quantity: number }>();

  const isNew = !existing;

  if (isNew) {
    const cnt = await env.DB.prepare(
      "SELECT COUNT(1) as n FROM cart_items WHERE session_id = ?"
    )
      .bind(input.session_id)
      .first<{ n: number }>();

    if ((cnt?.n ?? 0) >= CART_MAX_ITEMS) throw new Error("CART_TOO_LARGE");
  }

  const nextQty = Math.min(CART_MAX_QTY, (existing?.quantity ?? 0) + input.quantity);

  await env.DB.prepare(
    "INSERT OR REPLACE INTO cart_items (session_id, upc, quantity, created_at, updated_at) VALUES (?, ?, ?, ?, ?)"
  )
    .bind(input.session_id, input.upc, nextQty, existing ? t : t, t)
    .run();

  await touchCart(env, input.session_id);
  return getCart(env, input.session_id);
}

export async function setCartItemQuantity(
  env: EnvLike,
  input: { session_id: string; upc: string; quantity: number }
): Promise<Cart> {
  await ensureCart(env, input.session_id);

  const ok = await takeToken(env.DB, `cart_write:${input.session_id}`, RL_CART_WRITE);
  if (!ok) throw new Error("RATE_LIMITED");

  if (input.quantity > CART_MAX_QTY) throw new Error("QUANTITY_TOO_LARGE");

  const t = nowSec();
  await env.DB.prepare(
    "UPDATE cart_items SET quantity = ?, updated_at = ? WHERE session_id = ? AND upc = ?"
  )
    .bind(input.quantity, t, input.session_id, input.upc)
    .run();

  await touchCart(env, input.session_id);
  return getCart(env, input.session_id);
}

export async function removeCartItem(
  env: EnvLike,
  input: { session_id: string; upc: string }
): Promise<Cart> {
  await ensureCart(env, input.session_id);

  const ok = await takeToken(env.DB, `cart_write:${input.session_id}`, RL_CART_WRITE);
  if (!ok) throw new Error("RATE_LIMITED");

  await env.DB.prepare("DELETE FROM cart_items WHERE session_id = ? AND upc = ?")
    .bind(input.session_id, input.upc)
    .run();

  await touchCart(env, input.session_id);
  return getCart(env, input.session_id);
}

export async function clearCart(env: EnvLike, session_id: string): Promise<Cart> {
  await ensureCart(env, session_id);

  const ok = await takeToken(env.DB, `cart_write:${session_id}`, RL_CART_WRITE);
  if (!ok) throw new Error("RATE_LIMITED");

  await env.DB.prepare("DELETE FROM cart_items WHERE session_id = ?")
    .bind(session_id)
    .run();

  await touchCart(env, session_id);
  return getCart(env, session_id);
}
</file>

<file path="apps/api/src/services/krogerLivePrices.ts">
import { cacheGet, cachePut } from "../lib/cache";
import { distanceMeters } from "../lib/geo";
import { takeToken } from "../lib/rateLimit";
import { nowSec } from "../lib/time";
import {
  fetchKrogerLocations,
  fetchKrogerProductDetails,
  fetchKrogerToken,
  type KrogerLocation
} from "../providers/kroger";

type EnvLike = {
  DB: D1Database;
  OUTBOUND_USER_AGENT?: string;
  OUTBOUND_REFERER?: string;

  KROGER_LIVE_PRICES_ENABLED?: string;
  KROGER_CLIENT_ID?: string;
  KROGER_CLIENT_SECRET?: string;
  KROGER_BASE_URL?: string;
  KROGER_TOKEN_URL?: string;
};

export type LivePriceOverlayInput = {
  session_id: string;
  store: {
    id: string;
    name: string;
    lat: number;
    lon: number;
    tags: Record<string, unknown>;
  };
  upcs: string[];
  t: number;
};

export type LivePriceOverlayResult = {
  prices_by_upc: Map<string, { price_cents: number; observed_at: number; confidence: number }>;
  warnings: string[];
};

const MAX_UPCS_PER_QUOTE = 25;

const TOKEN_CACHE_KEY = "kroger:token:product.compact";
const TOKEN_MIN_TTL_SEC = 60;

const PRICE_CACHE_TTL_SEC = 10 * 60; // 10 minutes
const LOCATION_CACHE_MIN_FRESH_SEC = 90 * 24 * 60 * 60; // 90 days

const LOCATION_RADIUS_MILES = 2;
const MATCH_THRESHOLD_METERS = 700; // conservative match threshold

// Budgets (per session)
const RL_LOCATIONS = { capacity: 3, refillPerSec: 1 / 30, cost: 1 };
const RL_PRODUCTS  = { capacity: 25, refillPerSec: 1 / 2, cost: 1 };
const RL_TOKEN     = { capacity: 2, refillPerSec: 1 / 60, cost: 1 };

function isEnabled(env: EnvLike) {
  const v = (env.KROGER_LIVE_PRICES_ENABLED ?? "").toLowerCase();
  return v === "1" || v === "true" || v === "yes";
}

function hasCreds(env: EnvLike) {
  return !!(env.KROGER_CLIENT_ID && env.KROGER_CLIENT_SECRET);
}

async function mapLimit<T, R>(items: T[], limit: number, fn: (t: T) => Promise<R>): Promise<R[]> {
  const out: R[] = new Array(items.length);
  let idx = 0;

  const workers = new Array(Math.max(1, limit)).fill(null).map(async () => {
    while (true) {
      const i = idx++;
      if (i >= items.length) return;
      out[i] = await fn(items[i]);
    }
  });

  await Promise.all(workers);
  return out;
}

async function getAccessToken(env: EnvLike, session_id: string): Promise<string> {
  const cached = await cacheGet<{ access_token: string; expires_at: number }>(env.DB, TOKEN_CACHE_KEY);
  const now = nowSec();
  if (cached && cached.expires_at > now + TOKEN_MIN_TTL_SEC) return cached.access_token;

  const ok = await takeToken(env.DB, `kroger:${session_id}:token`, RL_TOKEN);
  if (!ok) throw new Error("KROGER_RATE_LIMITED_TOKEN");

  const token = await fetchKrogerToken(env.DB, {
    client_id: env.KROGER_CLIENT_ID!,
    client_secret: env.KROGER_CLIENT_SECRET!,
    token_url: env.KROGER_TOKEN_URL,
    scope: "product.compact",
    user_agent: env.OUTBOUND_USER_AGENT,
    referer: env.OUTBOUND_REFERER
  });

  const ttl = Math.max(TOKEN_MIN_TTL_SEC, (token.expires_in_sec ?? 1800) - 60);
  const payload = {
    access_token: token.access_token,
    expires_at: now + ttl
  };
  await cachePut(env.DB, TOKEN_CACHE_KEY, payload, ttl);

  return token.access_token;
}

async function getMappedLocationId(env: EnvLike, store_id: string): Promise<string | null> {
  const row = await env.DB.prepare(
    `SELECT provider_location_id, verified_at
     FROM store_provider_mappings
     WHERE store_id = ? AND provider = 'kroger'
     LIMIT 1`
  )
    .bind(store_id)
    .first<{ provider_location_id: string; verified_at: number }>();

  if (!row) return null;
  if (nowSec() - row.verified_at < LOCATION_CACHE_MIN_FRESH_SEC) return row.provider_location_id;
  return null;
}

async function upsertLocationId(
  env: EnvLike,
  store_id: string,
  location_id: string,
  match_method: string,
  match_score: number
) {
  const t = nowSec();
  await env.DB.prepare(
    `INSERT OR REPLACE INTO store_provider_mappings
      (store_id, provider, provider_location_id, match_method, match_score, created_at, verified_at)
     VALUES (?, 'kroger', ?, ?, ?, COALESCE((SELECT created_at FROM store_provider_mappings WHERE store_id = ? AND provider='kroger'), ?), ?)`
  )
    .bind(store_id, location_id, match_method, match_score, store_id, t, t)
    .run();
}

function pickBestLocation(store: LivePriceOverlayInput["store"], locations: KrogerLocation[]) {
  let best: { location: KrogerLocation; dist_m: number } | null = null;
  for (const loc of locations) {
    const d = distanceMeters(store.lat, store.lon, loc.lat, loc.lon);
    if (!best || d < best.dist_m) best = { location: loc, dist_m: d };
  }
  return best;
}

async function resolveLocationId(env: EnvLike, input: LivePriceOverlayInput): Promise<string | null> {
  const memo = await getMappedLocationId(env, input.store.id);
  if (memo) return memo;

  const ok = await takeToken(env.DB, `kroger:${input.session_id}:locations`, RL_LOCATIONS);
  if (!ok) return null;

  const token = await getAccessToken(env, input.session_id);
  const locations = await fetchKrogerLocations(env.DB, {
    access_token: token,
    base_url: env.KROGER_BASE_URL,
    lat: input.store.lat,
    lon: input.store.lon,
    radius_miles: LOCATION_RADIUS_MILES,
    limit: 10,
    user_agent: env.OUTBOUND_USER_AGENT,
    referer: env.OUTBOUND_REFERER
  });

  const best = pickBestLocation(input.store, locations);
  if (!best) return null;

  if (best.dist_m > MATCH_THRESHOLD_METERS) return null;

  const score = Math.max(0, 1 - best.dist_m / MATCH_THRESHOLD_METERS);
  await upsertLocationId(env, input.store.id, best.location.locationId, "auto_nearest", score);
  return best.location.locationId;
}

export async function getKrogerLivePriceOverlay(env: EnvLike, input: LivePriceOverlayInput): Promise<LivePriceOverlayResult> {
  const warnings: string[] = [];
  const prices_by_upc = new Map<string, { price_cents: number; observed_at: number; confidence: number }>();

  if (!isEnabled(env)) return { prices_by_upc, warnings };
  if (!hasCreds(env)) {
    warnings.push("KROGER_MISCONFIGURED_MISSING_CREDS");
    return { prices_by_upc, warnings };
  }

  const upcs = input.upcs.slice(0, MAX_UPCS_PER_QUOTE);

  let locationId: string | null = null;
  try {
    locationId = await resolveLocationId(env, input);
  } catch {
    warnings.push("KROGER_UNAVAILABLE_LOCATION_LOOKUP");
    return { prices_by_upc, warnings };
  }
  if (!locationId) return { prices_by_upc, warnings };

  let token: string;
  try {
    token = await getAccessToken(env, input.session_id);
  } catch {
    warnings.push("KROGER_UNAVAILABLE_AUTH");
    return { prices_by_upc, warnings };
  }

  const observed_at = nowSec();
  let partial = false;

  await mapLimit(upcs, 4, async (upc) => {
    const cacheKey = `kroger:price:${locationId}:${upc}`;
    const cached = await cacheGet<{ price_cents: number; observed_at: number }>(env.DB, cacheKey);

    if (cached && Number.isFinite(cached.price_cents)) {
      prices_by_upc.set(upc, { price_cents: cached.price_cents, observed_at: cached.observed_at, confidence: 0.95 });
      return;
    }

    const ok = await takeToken(env.DB, `kroger:${input.session_id}:products`, RL_PRODUCTS);
    if (!ok) {
      partial = true;
      return;
    }

    try {
      const r = await fetchKrogerProductDetails(env.DB, {
        access_token: token,
        base_url: env.KROGER_BASE_URL,
        location_id: locationId!,
        upc,
        user_agent: env.OUTBOUND_USER_AGENT,
        referer: env.OUTBOUND_REFERER
      });

      if (r.price_cents == null) {
        partial = true;
        return;
      }

      await cachePut(env.DB, cacheKey, { price_cents: r.price_cents, observed_at }, PRICE_CACHE_TTL_SEC);
      prices_by_upc.set(upc, { price_cents: r.price_cents, observed_at, confidence: 0.95 });
    } catch {
      partial = true;
    }
  });

  if (partial) warnings.push("KROGER_PARTIAL_OR_RATE_LIMITED");
  return { prices_by_upc, warnings };
}
</file>

<file path="apps/api/src/services/pricing.test.ts">
import { describe, expect, it } from "vitest";

function adjustedTotal(total: number, completeness: number): number {
  const denom = Math.max(0.25, completeness);
  return Math.round(total / denom);
}

describe("pricing helpers", () => {
  it("penalizes missing items by inflating adjusted total", () => {
    expect(adjustedTotal(1000, 1.0)).toBe(1000);
    expect(adjustedTotal(1000, 0.5)).toBe(2000);
    expect(adjustedTotal(1000, 0.25)).toBe(4000);
  });
});
</file>

<file path="apps/api/src/services/productCatalog.ts">
import type { Product, ProductLookupResponse, ProductSearchResponse } from "@pricecart/shared";
import { normalizeProductName, parseQuantity } from "@pricecart/shared";
import { cachePeek, cachePut } from "../lib/cache";
import { sha256Base64Url } from "../lib/hash";
import { takeToken } from "../lib/rateLimit";
import { nowSec } from "../lib/time";
import { OFF_ATTRIBUTION, offLookupByUpc, offSearch, type OffProductRaw } from "../providers/openFoodFacts";

const TTL_UPC_SEC = 60 * 60 * 24 * 7; // 7 days
const TTL_SEARCH_SEC = 60 * 60 * 6;   // 6 hours

// Conservative budgets (per session) - tune later
const RL_OFF_LOOKUP = { capacity: 10, refillPerSec: 1 / 6, cost: 1 }; // ~10/min
const RL_OFF_SEARCH = { capacity: 5, refillPerSec: 1 / 12, cost: 1 }; // ~5/min

function pickBrand(brands: string | null): string | null {
  if (!brands) return null;
  const first = brands.split(",")[0]?.trim();
  return first || null;
}

function toCanonicalProduct(raw: OffProductRaw): Product {
  const brand = pickBrand(raw.brands);
  const name = raw.product_name?.trim() || "Unknown product";

  return {
    upc: raw.code,
    name,
    brand,
    normalized_name: normalizeProductName({ name, brand }),
    quantity: parseQuantity(raw.quantity),
    image_url: raw.image_front_url,
    source: "openfoodfacts",
    source_url: raw.url,
    updated_at: nowSec()
  };
}

async function upsertProduct(db: D1Database, p: Product, rawHash: string | null) {
  await db
    .prepare(
      `INSERT OR REPLACE INTO products (
        upc, source, off_product_id, name, brand,
        quantity_value, quantity_unit,
        normalized_name, image_url, source_url,
        updated_at, raw_hash
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`
    )
    .bind(
      p.upc,
      p.source,
      p.source === "openfoodfacts" ? `off:${p.upc}` : null,
      p.name,
      p.brand,
      p.quantity.value,
      p.quantity.unit,
      p.normalized_name,
      p.image_url,
      p.source_url,
      p.updated_at,
      rawHash
    )
    .run();
}

async function recordRawPayload(db: D1Database, provider: string, upc: string, rawJson: unknown, rawHash: string) {
  await db
    .prepare(
      "INSERT OR REPLACE INTO product_provider_payloads (provider, upc, raw_json, raw_hash, fetched_at) VALUES (?, ?, ?, ?, ?)"
    )
    .bind(provider, upc, JSON.stringify(rawJson), rawHash, nowSec())
    .run();
}

async function readProductFromDb(db: D1Database, upc: string): Promise<Product | null> {
  const row = await db
    .prepare(
      "SELECT upc, source, name, brand, quantity_value, quantity_unit, normalized_name, image_url, source_url, updated_at FROM products WHERE upc = ? LIMIT 1"
    )
    .bind(upc)
    .first<{
      upc: string;
      source: "openfoodfacts" | "seed";
      name: string;
      brand: string | null;
      quantity_value: number | null;
      quantity_unit: string | null;
      normalized_name: string;
      image_url: string | null;
      source_url: string | null;
      updated_at: number;
    }>();

  if (!row) return null;
  return {
    upc: row.upc,
    name: row.name,
    brand: row.brand,
    normalized_name: row.normalized_name,
    quantity: { raw: null, value: row.quantity_value, unit: row.quantity_unit },
    image_url: row.image_url,
    source: row.source,
    source_url: row.source_url,
    updated_at: row.updated_at
  };
}

function validateUpc(upc: string): string {
  const u = upc.trim();
  if (!/^\d{8,14}$/.test(u)) throw new Error("INVALID_UPC");
  return u;
}

export async function lookupProduct(
  env: { DB: D1Database; OUTBOUND_USER_AGENT?: string; OUTBOUND_REFERER?: string; OFF_BASE_URL?: string },
  input: { upc: string; session_id: string },
  execCtx?: ExecutionContext
): Promise<ProductLookupResponse> {
  const upc = validateUpc(input.upc);
  const cacheKey = `off:product:${upc}`;

  const peek = await cachePeek<ProductLookupResponse>(env.DB, cacheKey);
  if (peek?.is_fresh) {
    return { ...peek.payload, data_mode: "cache", cache_state: "fresh" };
  }
  if (peek && !peek.is_fresh) {
    // stale-while-revalidate
    execCtx?.waitUntil(refreshLookup(env, upc, input.session_id).catch(() => {}));
    return { ...peek.payload, data_mode: "cache", cache_state: "stale" };
  }

  // No cache at all, try live (with fallback)
  try {
    return await refreshLookup(env, upc, input.session_id);
  } catch (e) {
    const fallback = await readProductFromDb(env.DB, upc);
    if (fallback) {
      return {
        data_mode: fallback.source === "seed" ? "seed" : "cache",
        product: fallback,
        attribution: OFF_ATTRIBUTION
      };
    }
    throw e;
  }
}

async function refreshLookup(
  env: { DB: D1Database; OUTBOUND_USER_AGENT?: string; OUTBOUND_REFERER?: string; OFF_BASE_URL?: string },
  upc: string,
  sessionId: string
): Promise<ProductLookupResponse> {
  const ok = await takeToken(env.DB, `rl:${sessionId}:openfoodfacts:lookup`, RL_OFF_LOOKUP);
  if (!ok) throw new Error("RATE_LIMIT_OFF_LOOKUP");

  const provider = "openfoodfacts";
  const raw = await offLookupByUpc(env, upc);

  // Hash raw-ish fields for drift detection (keep stable across irrelevant changes)
  const hashInput = JSON.stringify({
    code: raw.code,
    product_name: raw.product_name,
    brands: raw.brands,
    quantity: raw.quantity,
    image_front_url: raw.image_front_url,
    url: raw.url,
    last_modified_t: raw.last_modified_t
  });
  const rawHash = await sha256Base64Url(hashInput);

  const p = toCanonicalProduct(raw);
  await upsertProduct(env.DB, p, rawHash);
  await recordRawPayload(env.DB, provider, upc, raw, rawHash);

  const resp: ProductLookupResponse = {
    data_mode: "live",
    cache_state: "fresh",
    product: p,
    attribution: OFF_ATTRIBUTION
  };

  await cachePut(env.DB, `off:product:${upc}`, resp, TTL_UPC_SEC);
  return resp;
}

export async function searchProducts(
  env: { DB: D1Database; OUTBOUND_USER_AGENT?: string; OUTBOUND_REFERER?: string; OFF_BASE_URL?: string },
  input: { q: string; page: number; page_size: number; session_id: string },
  execCtx?: ExecutionContext
): Promise<ProductSearchResponse> {
  const q = input.q.trim();
  if (q.length < 2) throw new Error("INVALID_QUERY");

  const page = Math.max(1, Math.min(input.page, 25));
  const pageSize = Math.max(1, Math.min(input.page_size, 25));

  const qKey = await sha256Base64Url(q.toLowerCase());
  const cacheKey = `off:search:${qKey}:p=${page}:s=${pageSize}`;

  const peek = await cachePeek<ProductSearchResponse>(env.DB, cacheKey);
  if (peek?.is_fresh) return { ...peek.payload, data_mode: "cache", cache_state: "fresh" };
  if (peek && !peek.is_fresh) {
    execCtx?.waitUntil(refreshSearch(env, q, page, pageSize, input.session_id, cacheKey).catch(() => {}));
    return { ...peek.payload, data_mode: "cache", cache_state: "stale" };
  }

  return await refreshSearch(env, q, page, pageSize, input.session_id, cacheKey);
}

async function refreshSearch(
  env: { DB: D1Database; OUTBOUND_USER_AGENT?: string; OUTBOUND_REFERER?: string; OFF_BASE_URL?: string },
  q: string,
  page: number,
  pageSize: number,
  sessionId: string,
  cacheKey: string
): Promise<ProductSearchResponse> {
  const ok = await takeToken(env.DB, `rl:${sessionId}:openfoodfacts:search`, RL_OFF_SEARCH);
  if (!ok) throw new Error("RATE_LIMIT_OFF_SEARCH");

  const result = await offSearch(env, q, page, pageSize);

  const products = result.products
    .filter((p) => /^\d{8,14}$/.test(p.code))
    .map((p) => toCanonicalProduct(p));

  // Opportunistic upsert of search results
  for (const p of products) {
    await upsertProduct(env.DB, p, null);
  }

  const resp: ProductSearchResponse = {
    data_mode: "live",
    cache_state: "fresh",
    query: q,
    page,
    page_size: pageSize,
    total: result.total,
    products,
    attribution: OFF_ATTRIBUTION
  };

  await cachePut(env.DB, cacheKey, resp, TTL_SEARCH_SEC);
  return resp;
}
</file>

<file path="apps/api/src/services/productSearch.ts">
import { cacheGet, cachePut } from "../lib/cache";
import { sha256Base64Url } from "../lib/hash";
import { takeToken } from "../lib/rateLimit";

const TTL_OFF_SEARCH_SEC = 60 * 60; // 1 hour cache
const RL_OFF_SEARCH = { capacity: 10, refillPerSec: 1 / 6, cost: 1 }; // ~10/min per session

type OffSearchResponse = {
  products?: unknown[];
  count?: number | string;
};

function isRecord(value: unknown): value is Record<string, unknown> {
  return typeof value === "object" && value !== null;
}

function toStringValue(value: unknown): string | undefined {
  if (typeof value === "string") return value;
  if (typeof value === "number") return String(value);
  return undefined;
}

function toNumberValue(value: unknown): number | undefined {
  if (typeof value === "number") return value;
  if (typeof value === "string") {
    const parsed = Number(value);
    return Number.isFinite(parsed) ? parsed : undefined;
  }
  return undefined;
}

type EnvLike = {
  DB: D1Database;
  OUTBOUND_USER_AGENT?: string;
  OUTBOUND_REFERER?: string;
  OFF_BASE_URL?: string; // optional
};

export type ProductSummary = {
  code: string;
  product_name?: string;
  brands?: string;
  quantity?: string;
  image_url?: string;
  nutriscore_grade?: string;
};

export type ProductSearchResponse = {
  q: string;
  page: number;
  page_size: number;
  total_count: number;
  products: ProductSummary[];
  attribution: {
    text: string;
    links: { label: string; href: string }[];
  };
};

export async function productSearch(
  env: EnvLike,
  input: { q: string; page: number; page_size: number; session_id: string }
): Promise<ProductSearchResponse> {
  const q = input.q.trim();
  const page = Math.max(1, input.page);
  const pageSize = Math.min(Math.max(1, input.page_size), 50);

  const cacheKey = `off:search:${await sha256Base64Url(
    `${q.toLowerCase()}|p=${page}|s=${pageSize}`
  )}`;

  const cached = await cacheGet<ProductSearchResponse>(env.DB, cacheKey);
  if (cached) return cached;

  const ok = await takeToken(env.DB, `rl:${input.session_id}:off_search`, RL_OFF_SEARCH);
  if (!ok) throw new Error("RATE_LIMIT_OFF_SEARCH");

  const base = (env.OFF_BASE_URL || "https://world.openfoodfacts.org").replace(/\/+$/, "");
  const url = new URL(`${base}/cgi/search.pl`);
  url.searchParams.set("action", "process");
  url.searchParams.set("search_terms", q);
  url.searchParams.set("search_simple", "1");
  url.searchParams.set("json", "1");
  url.searchParams.set("page", String(page));
  url.searchParams.set("page_size", String(pageSize));

  const headers = new Headers();
  // OFF asks for a custom User-Agent to identify your app. :contentReference[oaicite:2]{index=2}
  headers.set("User-Agent", env.OUTBOUND_USER_AGENT || "PriceCart/0.1 (dev)");
  if (env.OUTBOUND_REFERER) headers.set("Referer", env.OUTBOUND_REFERER);

  const resp = await fetch(url.toString(), { headers });
  if (resp.status === 429) throw new Error("RATE_LIMIT_OFF_REMOTE");
  if (!resp.ok) throw new Error(`OFF_HTTP_${resp.status}`);

  const rawData = await resp.json();
  const data = isRecord(rawData) ? (rawData as OffSearchResponse) : {};
  const productsRaw: unknown[] = Array.isArray(data.products) ? data.products : [];

  const products: ProductSummary[] = productsRaw
    .map((p) => {
      if (!isRecord(p)) return null;
      const code = toStringValue(p["code"])?.trim();
      if (!code) return null;

      return {
        code,
        product_name: toStringValue(p["product_name"]) ?? toStringValue(p["product_name_en"]),
        brands: toStringValue(p["brands"]),
        quantity: toStringValue(p["quantity"]),
        image_url: toStringValue(p["image_url"]),
        nutriscore_grade: toStringValue(p["nutriscore_grade"])
      } satisfies ProductSummary;
    })
    .filter(Boolean) as ProductSummary[];

  const out: ProductSearchResponse = {
    q,
    page,
    page_size: pageSize,
    total_count: toNumberValue(data.count) ?? products.length,
    products,
    attribution: {
      text: "Data from Open Food Facts",
      links: [{ label: "Open Food Facts", href: "https://world.openfoodfacts.org/" }]
    }
  };

  await cachePut(env.DB, cacheKey, out, TTL_OFF_SEARCH_SEC);
  return out;
}
</file>

<file path="apps/api/src/services/storeDiscovery.ts">
import type { StoreSearchResponse } from "@pricecart/shared";
import { cacheGet, cachePut } from "../lib/cache";
import { distanceMeters } from "../lib/geo";
import { sha256Base64Url } from "../lib/hash";
import { takeToken } from "../lib/rateLimit";
import { nowSec } from "../lib/time";
import { geocode } from "../providers/nominatim";
import { queryNearbyStores } from "../providers/overpass";

const TTL_GEOCODE_SEC = 60 * 60 * 24 * 30; // 30 days
const TTL_STORES_SEC = 60 * 60 * 24;      // 1 day

// Budgets (demo-friendly, provider-friendly)
const RL_GEOCODE = { capacity: 10, refillPerSec: 1 / 10, cost: 1 };   // ~10/min max per session
const RL_OVERPASS = { capacity: 10, refillPerSec: 1 / 30, cost: 1 };  // ~10/5min max per session

export async function storeSearch(
  env: { DB: D1Database; OUTBOUND_USER_AGENT?: string; OUTBOUND_REFERER?: string },
  input: { location: string; radius_m: number; session_id: string }
): Promise<StoreSearchResponse> {
  const radius = Math.min(Math.max(input.radius_m, 250), 20000); // clamp 250m..20km

  // 1) Geocode with caching + rate limit
  const locNorm = input.location.trim().toLowerCase();
  const geoKey = `geo:${await sha256Base64Url(locNorm)}`;
  let center = await cacheGet<{ lat: number; lon: number }>(env.DB, geoKey);

  if (!center) {
    const ok = await takeToken(env.DB, `rl:${input.session_id}:nominatim`, RL_GEOCODE);
    if (!ok) throw new Error("RATE_LIMIT_GEOCODE");

    try {
      const g = await geocode(env, input.location);
      center = { lat: g.lat, lon: g.lon };
      await cachePut(env.DB, geoKey, center, TTL_GEOCODE_SEC);
    } catch (geocodeErr) {
      try {
        const fallback = await seedResponse(env, radius);
        console.log(
          JSON.stringify({
            level: "warn",
            message: "geocode failed, falling back to seeded stores",
            err: String(geocodeErr)
          })
        );
        return fallback;
      } catch {
        throw geocodeErr;
      }
    }
  }

  // 2) Store query with caching + rate limit + fallback
  const storesKey = `stores:${await sha256Base64Url(
    `${center.lat.toFixed(3)},${center.lon.toFixed(3)}:r=${radius}`
  )}`;

  const cached = await cacheGet<{ stores: StoreSearchResponse["stores"] }>(env.DB, storesKey);
  if (cached?.stores?.length) {
    return {
      center,
      radius_m: radius,
      data_mode: "cache",
      stores: cached.stores,
      attribution: osmAttribution()
    };
  }

  // Try live Overpass, else seed fallback.
  try {
    const ok = await takeToken(env.DB, `rl:${input.session_id}:overpass`, RL_OVERPASS);
    if (!ok) throw new Error("RATE_LIMIT_OVERPASS");

    const raw = await queryNearbyStores(env, center, radius);

    const stores = raw
      .map((s) => ({
        id: s.external_id,
        name: s.name,
        lat: s.lat,
        lon: s.lon,
        distance_m: Math.round(distanceMeters(center, { lat: s.lat, lon: s.lon })),
        tags: s.tags
      }))
      .sort((a, b) => a.distance_m - b.distance_m)
      .slice(0, 50);

    await cachePut(env.DB, storesKey, { stores }, TTL_STORES_SEC);

    // Opportunistic upsert into stores table (useful later, not required to return)
    const t = nowSec();
    const stmt = env.DB.prepare(
      "INSERT OR REPLACE INTO stores (id, source, external_id, name, lat, lon, tags_json, last_seen_at) VALUES (?, 'osm', ?, ?, ?, ?, ?, ?)"
    );
    const batch = stores.map((st) =>
      stmt.bind(st.id, st.id, st.name, st.lat, st.lon, JSON.stringify(st.tags ?? {}), t)
    );
    await env.DB.batch(batch);

    return {
      center,
      radius_m: radius,
      data_mode: "live",
      stores,
      attribution: osmAttribution()
    };
  } catch {
    return seedResponse(env, radius, center);
  }
}

function safeJson(s: string | null | undefined): Record<string, string> {
  if (!s) return {};
  try {
    return JSON.parse(s) as Record<string, string>;
  } catch {
    return {};
  }
}

function osmAttribution() {
  return {
    text: " OpenStreetMap contributors",
    links: [{ label: "OpenStreetMap", href: "https://www.openstreetmap.org/copyright" }]
  };
}

async function seedResponse(
  env: { DB: D1Database },
  radius: number,
  centerOverride?: { lat: number; lon: number }
): Promise<StoreSearchResponse> {
  const seed = await env.DB
    .prepare("SELECT id, name, lat, lon, tags_json FROM stores WHERE source = 'seed'")
    .all<{ id: string; name: string; lat: number; lon: number; tags_json: string }>();

  const rows = seed.results || [];
  const center =
    centerOverride ?? (rows.length ? centerFromSeedRows(rows) : null);

  if (!center) throw new Error("NO_SEED_STORES");

  const stores = rows
    .map((s) => ({
      id: s.id,
      name: s.name,
      lat: s.lat,
      lon: s.lon,
      distance_m: Math.round(distanceMeters(center, { lat: s.lat, lon: s.lon })),
      tags: safeJson(s.tags_json)
    }))
    .sort((a, b) => a.distance_m - b.distance_m);

  return {
    center,
    radius_m: radius,
    data_mode: "seed",
    stores,
    attribution: osmAttribution()
  };
}

function centerFromSeedRows(rows: Array<{ lat: number; lon: number }>) {
  if (!rows.length) return null;

  const { lat, lon } = rows.reduce(
    (acc, row) => {
      acc.lat += row.lat;
      acc.lon += row.lon;
      return acc;
    },
    { lat: 0, lon: 0 }
  );

  return { lat: lat / rows.length, lon: lon / rows.length };
}
</file>

<file path="apps/api/src/types/cloudflare-runtime.d.ts">
/// <reference types="@cloudflare/workers-types" />
export { };
</file>

<file path="apps/api/src/types/pricecart-shared.d.ts">
// Intentionally empty.
//
// This file previously provided a stub `declare module "@pricecart/shared"` to unblock builds.
// `@pricecart/shared` is now a real workspace dependency (packages/shared) that ships its own types.

export { };
</file>

<file path="apps/api/src/App.css">
#root {
	max-width: 1280px;
	margin: 0 auto;
	padding: 2rem;
	text-align: center;
}

.logo {
	height: 6em;
	padding: 1.5em;
	will-change: filter;
	transition: filter 300ms;
}
.logo:hover {
	filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
	filter: drop-shadow(0 0 2em #61dafbaa);
}
.logo.cloudflare:hover {
	filter: drop-shadow(0 0 2em #f6821faa);
}

@keyframes logo-spin {
	from {
		transform: rotate(0deg);
	}
	to {
		transform: rotate(360deg);
	}
}

@media (prefers-reduced-motion: no-preference) {
	a:nth-of-type(2) .logo {
		animation: logo-spin infinite 20s linear;
	}
}

.card {
	padding: 2em;
}

.read-the-docs {
	color: #888;
}
</file>

<file path="apps/api/src/App.tsx">
import { useState } from 'react'
import reactLogo from './assets/react.svg'
import viteLogo from '/vite.svg'
import cloudflareLogo from './assets/Cloudflare_Logo.svg'
import './App.css'

function App() {
  const [count, setCount] = useState(0)
  const [name, setName] = useState('unknown')

  return (
    <>
      <div>
        <a href='https://vite.dev' target='_blank'>
          <img src={viteLogo} className='logo' alt='Vite logo' />
        </a>
        <a href='https://react.dev' target='_blank'>
          <img src={reactLogo} className='logo react' alt='React logo' />
        </a>
        <a href='https://workers.cloudflare.com/' target='_blank'>
          <img src={cloudflareLogo} className='logo cloudflare' alt='Cloudflare logo' />
        </a>
      </div>
      <h1>Vite + React + Cloudflare</h1>
      <div className='card'>
        <button
          onClick={() => setCount((count) => count + 1)}
          aria-label='increment'
        >
          count is {count}
        </button>
        <p>
          Edit <code>src/App.tsx</code> and save to test HMR
        </p>
      </div>
      <div className='card'>
        <button
          onClick={() => {
            fetch('/api/')
              .then((res) => res.json() as Promise<{ name: string }>)
              .then((data) => setName(data.name))
          }}
          aria-label='get name'
        >
          Name from API is: {name}
        </button>
        <p>
          Edit <code>worker/index.ts</code> to change the name
        </p>
      </div>
      <p className='read-the-docs'>
        Click on the Vite and React logos to learn more
      </p>
    </>
  )
}

export default App
</file>

<file path="apps/api/src/index.css">
:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}
</file>

<file path="apps/api/src/main.tsx">
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import App from "./App";

createRoot(document.getElementById("root")!).render(
  <StrictMode>
    <App />
  </StrictMode>
);
</file>

<file path="apps/api/src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="apps/api/worker/index.ts">
import type { Env } from "../src/env";
import app from "../src/index";

export default {
  async fetch(
    request: Request,
    env: Env & { ASSETS?: Fetcher },
    ctx: ExecutionContext
  ): Promise<Response> {
    const url = new URL(request.url);

    // Keep the Vite template demo endpoint working (App.tsx fetches /api/)
    // BUT do not swallow real API routes like /api/health, /api/stores/search, etc.
    if (url.pathname === "/api" || url.pathname === "/api/") {
      return Response.json({ name: "Cloudflare" });
    }

    const isApiPrefixed = url.pathname.startsWith("/api/");

    // Support both:
    // - /health, /stores/search, /products/search
    // - /api/health, /api/stores/search, /api/products/search
    if (isApiPrefixed) {
      url.pathname = url.pathname.slice("/api".length) || "/";
      request = new Request(url.toString(), request);
    }

    const res = await app.fetch(request, env, ctx);

    // Never fall back to static assets for /api/* calls.
    if (isApiPrefixed) return res;

    // If the Hono app didn't match, let the SPA/static assets system try (if present).
    if (res.status === 404 && env.ASSETS?.fetch) {
      return env.ASSETS.fetch(request);
    }

    return res;
  }
};
</file>

<file path="apps/api/eslint.config.js">
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'
import { globalIgnores } from 'eslint/config'

export default tseslint.config([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      js.configs.recommended,
      tseslint.configs.recommended,
      reactHooks.configs['recommended-latest'],
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
  },
])
</file>

<file path="apps/api/index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React + TS</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="apps/api/README.md">
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:

```js
export default tseslint.config([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...

      // Remove tseslint.configs.recommended and replace with this
      ...tseslint.configs.recommendedTypeChecked,
      // Alternatively, use this for stricter rules
      ...tseslint.configs.strictTypeChecked,
      // Optionally, add this for stylistic rules
      ...tseslint.configs.stylisticTypeChecked,

      // Other configs...
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```

You can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:

```js
// eslint.config.js
import reactX from 'eslint-plugin-react-x'
import reactDom from 'eslint-plugin-react-dom'

export default tseslint.config([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...
      // Enable lint rules for React
      reactX.configs['recommended-typescript'],
      // Enable lint rules for React DOM
      reactDom.configs.recommended,
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```
</file>

<file path="apps/api/tsconfig.app.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}
</file>

<file path="apps/api/tsconfig.client.json">
{
  "compilerOptions": {
    "composite": true,
    "tsBuildInfoFile": "./node_modules/.cache/tsconfig.client.tsbuildinfo",

    "target": "ES2022",
    "lib": ["ES2022", "DOM", "DOM.Iterable"],

    "jsx": "react-jsx",

    "module": "ESNext",
    "moduleResolution": "Bundler",

    "strict": true,
    "skipLibCheck": true,
    "noEmit": true
  },
  "include": [
    "src/**/*.ts",
    "src/**/*.tsx",
    "src/**/*.d.ts"
  ],
  "exclude": [
    "worker/**",
    "src/**/*.test.*",
    "src/**/*.spec.*"
  ]
}
</file>

<file path="apps/api/tsconfig.json">
{
  "files": [],
  "references": [
    { "path": "./tsconfig.worker.json" },
    { "path": "./tsconfig.client.json" }
  ]
}
</file>

<file path="apps/api/tsconfig.node.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="apps/api/tsconfig.worker.json">
{
  "compilerOptions": {
    "composite": true,
    "tsBuildInfoFile": "./node_modules/.cache/tsconfig.worker.tsbuildinfo",

    "target": "ES2022",
    "lib": ["ES2022"],

    "module": "ESNext",
    "moduleResolution": "Bundler",

    "strict": true,
    "skipLibCheck": true,
    "noEmit": true,

    "types": ["./worker-configuration.d.ts"]
  },
  "include": [
    "worker/**/*.ts",
    "src/**/*.ts",
    "src/**/*.d.ts"
  ],
  "exclude": [
    "src/**/*.tsx",
    "src/**/*.test.*",
    "src/**/*.spec.*",
    "src/vite-env.d.ts"
  ]
}
</file>

<file path="apps/api/wrangler.jsonc">
/**
 * For more details on how to configure Wrangler, refer to:
 * https://developers.cloudflare.com/workers/wrangler/configuration/
 */
{
  "$schema": "node_modules/wrangler/config-schema.json",
  "name": "api",
  "main": "worker/index.ts",
  "compatibility_date": "2025-12-25",

  "observability": { "enabled": true },

  "vars": {
    "OUTBOUND_USER_AGENT": "PriceCart/0.1 (contact: you@example.com)",
    "OUTBOUND_REFERER": "http://localhost:5173",
    "OFF_BASE_URL": "https://world.openfoodfacts.org"
  },

  "assets": {
    "not_found_handling": "single-page-application",
    "binding": "ASSETS",
    "run_worker_first": ["/api/*", "/health", "/stores/*", "/products/*"]
  },

  "d1_databases": [
    {
      "binding": "DB",
      "database_name": "pricecart",
      "database_id": "f0f7e12d-54da-4aa0-a94e-d84a80a71169"
    }
  ]
}
</file>

<file path="apps/api/wrangler.toml">
name = "api"
main = "worker/index.ts"
compatibility_date = "2025-12-25"

[observability]
enabled = true

[vars]
OUTBOUND_USER_AGENT = "PriceCart/0.1 (contact: you@example.com)"
OUTBOUND_REFERER = "http://localhost:5173"
OFF_BASE_URL = "https://world.openfoodfacts.org"

[assets]
binding = "ASSETS"
not_found_handling = "single-page-application"
run_worker_first = ["/api/*", "/health", "/stores/*", "/products/*"]

[[d1_databases]]
binding = "DB"
database_name = "pricecart"
database_id = "f0f7e12d-54da-4aa0-a94e-d84a80a71169"
</file>

<file path="apps/web/src/lib/cart.ts">
import type { Cart } from "@pricecart/shared";
import { CartSchema } from "@pricecart/shared";
import { useCallback, useEffect, useMemo, useState } from "react";
import { addCartItem, clearCart, getCart, removeCartItem, setCartItem } from "./api";

const STORAGE_KEY = "pricecart_cart_v1";

function loadLocalCart(): Cart | null {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return null;
    const parsed = CartSchema.safeParse(JSON.parse(raw));
    return parsed.success ? parsed.data : null;
  } catch {
    return null;
  }
}

function saveLocalCart(cart: Cart) {
  localStorage.setItem(STORAGE_KEY, JSON.stringify(cart));
}

export type CartState = {
  cart: Cart | null;
  status: "idle" | "loading" | "ready" | "error";
  error: string | null;
};

export function useCart() {
  const [state, setState] = useState<CartState>(() => {
    const local = loadLocalCart();
    return { cart: local, status: local ? "ready" : "idle", error: null };
  });

  const refresh = useCallback(async () => {
    setState((s) => ({ ...s, status: "loading", error: null }));
    try {
      const c = await getCart();
      saveLocalCart(c);
      setState({ cart: c, status: "ready", error: null });
    } catch (e) {
      setState((s) => ({ ...s, status: "error", error: e instanceof Error ? e.message : String(e) }));
    }
  }, []);

  useEffect(() => {
    // Always reconcile with the backend on mount
    void refresh();
  }, [refresh]);

  const actions = useMemo(() => {
    return {
      async add(upc: string, quantity: number = 1) {
        setState((s) => ({ ...s, status: "loading", error: null }));
        try {
          const c = await addCartItem({ upc, quantity });
          saveLocalCart(c);
          setState({ cart: c, status: "ready", error: null });
        } catch (e) {
          setState((s) => ({ ...s, status: "error", error: e instanceof Error ? e.message : String(e) }));
        }
      },
      async setQuantity(upc: string, quantity: number) {
        setState((s) => ({ ...s, status: "loading", error: null }));
        try {
          const c = await setCartItem(upc, { quantity });
          saveLocalCart(c);
          setState({ cart: c, status: "ready", error: null });
        } catch (e) {
          setState((s) => ({ ...s, status: "error", error: e instanceof Error ? e.message : String(e) }));
        }
      },
      async remove(upc: string) {
        setState((s) => ({ ...s, status: "loading", error: null }));
        try {
          const c = await removeCartItem(upc);
          saveLocalCart(c);
          setState({ cart: c, status: "ready", error: null });
        } catch (e) {
          setState((s) => ({ ...s, status: "error", error: e instanceof Error ? e.message : String(e) }));
        }
      },
      async clear() {
        setState((s) => ({ ...s, status: "loading", error: null }));
        try {
          const c = await clearCart();
          saveLocalCart(c);
          setState({ cart: c, status: "ready", error: null });
        } catch (e) {
          setState((s) => ({ ...s, status: "error", error: e instanceof Error ? e.message : String(e) }));
        }
      },
      refresh
    };
  }, [refresh]);

  return { ...state, ...actions };
}
</file>

<file path="apps/web/src/lib/cartReducer.test.ts">
import { describe, expect, it } from "vitest";
import { normalizeCart } from "./cartReducer";

describe("normalizeCart", () => {
  it("merges duplicate UPCs", () => {
    const out = normalizeCart({ items: [{ upc: "1", count: 1 }, { upc: "1", count: 2 }] });
    expect(out.items).toEqual([{ upc: "1", count: 3 }]);
  });

  it("clamps minimum quantity to 1", () => {
    const out = normalizeCart({ items: [{ upc: "1", count: 0 }] });
    expect(out.items[0].count).toBe(1);
  });
});
</file>

<file path="apps/web/src/lib/cartReducer.ts">
export type CartItem = { upc: string; count: number };
export type CartModel = { items: CartItem[] };

export const CART_MAX_QTY = 99;

export function normalizeCart(model: CartModel): CartModel {
  const m = new Map<string, number>();
  for (const it of model.items) {
    const next = (m.get(it.upc) ?? 0) + it.count;
    m.set(it.upc, Math.min(CART_MAX_QTY, Math.max(1, next)));
  }
  return { items: Array.from(m.entries()).map(([upc, count]) => ({ upc, count })) };
}
</file>

<file path="apps/web/src/lib/session.ts">
export function getSessionId(): string {
  const k = "pricecart_session";
  const existing = localStorage.getItem(k);
  if (existing) return existing;
  const v = crypto.randomUUID();
  localStorage.setItem(k, v);
  return v;
}
</file>

<file path="apps/web/src/App.css">
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}
</file>

<file path="apps/web/src/index.css">
:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}
</file>

<file path="apps/web/src/main.tsx">
import "leaflet/dist/leaflet.css";

import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";
import "./index.css";

ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
</file>

<file path="apps/web/.gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path="apps/web/eslint.config.js">
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      js.configs.recommended,
      tseslint.configs.recommended,
      reactHooks.configs.flat.recommended,
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
  },
])
</file>

<file path="apps/web/index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>web</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="apps/web/README.md">
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) (or [oxc](https://oxc.rs) when used in [rolldown-vite](https://vite.dev/guide/rolldown)) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## React Compiler

The React Compiler is not enabled on this template because of its impact on dev & build performances. To add it, see [this documentation](https://react.dev/learn/react-compiler/installation).

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:

```js
export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...

      // Remove tseslint.configs.recommended and replace with this
      tseslint.configs.recommendedTypeChecked,
      // Alternatively, use this for stricter rules
      tseslint.configs.strictTypeChecked,
      // Optionally, add this for stylistic rules
      tseslint.configs.stylisticTypeChecked,

      // Other configs...
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```

You can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:

```js
// eslint.config.js
import reactX from 'eslint-plugin-react-x'
import reactDom from 'eslint-plugin-react-dom'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...
      // Enable lint rules for React
      reactX.configs['recommended-typescript'],
      // Enable lint rules for React DOM
      reactDom.configs.recommended,
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```
</file>

<file path="apps/web/tsconfig.app.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "types": ["vite/client"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}
</file>

<file path="apps/web/tsconfig.json">
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}
</file>

<file path="apps/web/tsconfig.node.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "types": ["node"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="apps/web/vite.config.ts">
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
})
</file>

<file path="packages/shared/src/cart.ts">
import { z } from "zod";
import { QuantitySchema } from "./product.js";

export const CartLineSchema = z.object({
  upc: z.string(),
  name: z.string(),
  brand: z.string().nullable().default(null),
  quantity: QuantitySchema,
  image_url: z.string().url().nullable().default(null),
  count: z.number().int().positive()
});
export type CartLine = z.infer<typeof CartLineSchema>;

export const CartSchema = z.object({
  session_id: z.string(),
  updated_at: z.number().int().nonnegative(),
  item_count: z.number().int().nonnegative(),
  total_units: z.number().int().nonnegative(),
  items: z.array(CartLineSchema)
});
export type Cart = z.infer<typeof CartSchema>;

export const CartAddItemRequestSchema = z.object({
  upc: z.string(),
  quantity: z.number().int().positive()
});
export type CartAddItemRequest = z.infer<typeof CartAddItemRequestSchema>;

export const CartSetItemRequestSchema = z.object({
  quantity: z.number().int().positive()
});
export type CartSetItemRequest = z.infer<typeof CartSetItemRequestSchema>;
</file>

<file path="packages/shared/src/pricing.ts">
import { z } from "zod";

export const PriceSourceSchema = z.enum(["open_prices", "community", "kroger"]);
export type PriceSource = z.infer<typeof PriceSourceSchema>;

export const EvidenceTypeSchema = z.enum(["dataset", "manual", "receipt_text"]);
export type EvidenceType = z.infer<typeof EvidenceTypeSchema>;

export const FreshnessBucketSchema = z.enum(["fresh", "recent", "stale", "old"]);
export type FreshnessBucket = z.infer<typeof FreshnessBucketSchema>;

export const MoneySchema = z.object({
  currency: z.string().min(3).max(8).default("USD"),
  cents: z.number().int().nonnegative()
});

export const QuoteLineSchema = z.object({
  upc: z.string(),
  quantity: z.number().int().positive(),

  unit_price_cents: z.number().int().nonnegative().nullable().default(null),
  extended_price_cents: z.number().int().nonnegative().nullable().default(null),

  missing: z.boolean(),
  observed_at: z.number().int().nonnegative().nullable().default(null),
  source: PriceSourceSchema.nullable().default(null),
  evidence_type: EvidenceTypeSchema.nullable().default(null),
  confidence: z.number().min(0).max(1).nullable().default(null),
  freshness: FreshnessBucketSchema.nullable().default(null)
});
export type QuoteLine = z.infer<typeof QuoteLineSchema>;

export const QuoteStoreSchema = z.object({
  store_id: z.string(),
  store_name: z.string(),
  currency: z.string().default("USD"),

  item_count: z.number().int().nonnegative(),
  matched_count: z.number().int().nonnegative(),
  missing_count: z.number().int().nonnegative(),
  completeness: z.number().min(0).max(1),

  total_cents: z.number().int().nonnegative(),
  adjusted_total_cents: z.number().int().nonnegative(),

  lines: z.array(QuoteLineSchema)
});
export type QuoteStore = z.infer<typeof QuoteStoreSchema>;

export const CartQuoteRequestSchema = z.object({
  store_ids: z.array(z.string()).min(1).max(20)
});
export type CartQuoteRequest = z.infer<typeof CartQuoteRequestSchema>;

export const CartQuoteResponseSchema = z.object({
  session_id: z.string(),
  generated_at: z.number().int().nonnegative(),
  currency: z.string().default("USD"),
  cheapest_store_id: z.string().nullable().default(null),
  stores: z.array(QuoteStoreSchema),
  warnings: z.array(z.string()).default([])
});
export type CartQuoteResponse = z.infer<typeof CartQuoteResponseSchema>;

export const PriceSubmitRequestSchema = z.object({
  store_id: z.string().min(1).max(128),
  upc: z.string().min(1).max(64),
  price_cents: z.number().int().min(1).max(1_000_000),
  currency: z.string().min(3).max(8).optional().default("USD"),
  observed_at: z.number().int().nonnegative().optional(),
  evidence_type: EvidenceTypeSchema.optional().default("manual")
});
export type PriceSubmitRequest = z.infer<typeof PriceSubmitRequestSchema>;

export const PriceSubmitResponseSchema = z.object({
  ok: z.literal(true),
  snapshot_id: z.string()
});
export type PriceSubmitResponse = z.infer<typeof PriceSubmitResponseSchema>;
</file>

<file path="packages/shared/src/product.ts">
import { z } from "zod";

export const QuantitySchema = z.object({
  raw: z.string().nullable().default(null),
  value: z.number().nullable().default(null),
  unit: z.string().nullable().default(null)
});

export const ProductSchema = z.object({
  upc: z.string(),
  name: z.string(),
  brand: z.string().nullable().default(null),
  normalized_name: z.string(),
  quantity: QuantitySchema,
  image_url: z.string().url().nullable().default(null),
  source: z.enum(["openfoodfacts", "seed"]),
  source_url: z.string().url().nullable().default(null),
  updated_at: z.number().int()
});

export type Product = z.infer<typeof ProductSchema>;

export const ProductSummarySchema = ProductSchema;
export type ProductSummary = z.infer<typeof ProductSummarySchema>;

export const AttributionSchema = z.object({
  text: z.string(),
  links: z.array(z.object({ label: z.string(), href: z.string().url() }))
});

export const ProductLookupResponseSchema = z.object({
  data_mode: z.enum(["live", "cache", "seed"]),
  cache_state: z.enum(["fresh", "stale"]).optional(),
  product: ProductSchema,
  attribution: AttributionSchema
});
export type ProductLookupResponse = z.infer<typeof ProductLookupResponseSchema>;

export const ProductSearchResponseSchema = z.object({
  data_mode: z.enum(["live", "cache"]),
  cache_state: z.enum(["fresh", "stale"]).optional(),
  query: z.string(),
  page: z.number().int().positive(),
  page_size: z.number().int().positive(),
  total: z.number().int().nonnegative(),
  products: z.array(ProductSummarySchema),
  attribution: AttributionSchema
});
export type ProductSearchResponse = z.infer<typeof ProductSearchResponseSchema>;

// -------------------------
// Normalization helpers
// -------------------------

export type Synonyms = Record<string, string[]>; // canonical -> synonyms

const DEFAULT_SYNONYMS: Synonyms = {
  oz: ["ounce", "ounces"],
  lb: ["lbs", "pound", "pounds"],
  pcs: ["pc", "piece", "pieces"],
  ea: ["each"]
};

function buildSynonymMap(s: Synonyms): Record<string, string> {
  const m: Record<string, string> = {};
  for (const [canon, alts] of Object.entries(s)) {
    m[canon] = canon;
    for (const a of alts) m[a] = canon;
  }
  return m;
}

export function normalizeText(input: string): string {
  return input
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, " ")
    .replace(/\s+/g, " ")
    .trim();
}

export function normalizeProductName(args: {
  name: string;
  brand?: string | null;
  synonyms?: Synonyms;
}): string {
  const synMap = buildSynonymMap(args.synonyms ?? DEFAULT_SYNONYMS);

  const base = normalizeText(`${args.brand ?? ""} ${args.name}`);
  const tokens = base.split(" ").filter(Boolean);

  const normalized = tokens.map((t) => synMap[t] ?? t);
  return normalized.join(" ");
}

export function parseQuantity(raw: string | null | undefined): { raw: string | null; value: number | null; unit: string | null } {
  if (!raw) return { raw: null, value: null, unit: null };

  // Examples seen in the wild: "500 g", "1L", "16 oz", "0.5 kg"
  const s = raw.trim();

  const m = s.match(/^\s*(\d+(?:\.\d+)?)\s*([a-zA-Z]+)\s*$/);
  if (!m) return { raw: s, value: null, unit: null };

  const value = Number(m[1]);
  if (!Number.isFinite(value)) return { raw: s, value: null, unit: null };

  const unitRaw = m[2].toLowerCase();
  const unit = normalizeUnit(unitRaw);

  return { raw: s, value, unit };
}

function normalizeUnit(u: string): string | null {
  const map: Record<string, string> = {
    g: "g",
    gram: "g",
    grams: "g",
    kg: "kg",
    ml: "ml",
    l: "l",
    liter: "l",
    liters: "l",
    oz: "oz",
    ounce: "oz",
    ounces: "oz",
    lb: "lb",
    lbs: "lb",
    ct: "ct",
    count: "ct",
    ea: "ea"
  };
  return map[u] ?? null;
}
</file>

<file path="packages/shared/src/store.ts">
import { z } from "zod";

export const StoreTagSetSchema = z.record(z.string(), z.string()).default({});

export const StoreSchema = z.object({
  id: z.string(),
  name: z.string(),
  lat: z.number(),
  lon: z.number(),
  distance_m: z.number().nonnegative(),
  tags: StoreTagSetSchema
});

export type Store = z.infer<typeof StoreSchema>;

export const StoreSearchResponseSchema = z.object({
  center: z.object({ lat: z.number(), lon: z.number() }),
  radius_m: z.number().int().positive(),
  data_mode: z.enum(["live", "cache", "seed"]),
  stores: z.array(StoreSchema),
  attribution: z.object({
    text: z.string(),
    links: z.array(z.object({ label: z.string(), href: z.string() }))
  })
});

export type StoreSearchResponse = z.infer<typeof StoreSearchResponseSchema>;
</file>

<file path="packages/shared/package.json">
{
  "name": "@pricecart/shared",
  "version": "0.0.1",
  "private": true,
  "type": "module",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "scripts": {
    "build": "tsc -p tsconfig.json",
    "typecheck": "tsc -p tsconfig.json --noEmit"
  },
  "dependencies": {
    "zod": "4.2.1"
  },
  "devDependencies": {
    "typescript": "~5.8.3"
  }
}
</file>

<file path="packages/shared/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "declaration": true,
    "outDir": "dist",
    "strict": true
  },
  "include": ["src"]
}
</file>

<file path=".gitignore">
# Dependencies
**/node_modules/

# Build output
**/dist/
**/dist-ssr/
packages/shared/dist/

# TypeScript build artifacts
**/*.tsbuildinfo

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
pnpm-debug.log*

# Env files (keep examples)
.env
.env.*
!.env.example

# Cloudflare Wrangler
**/.wrangler/
.dev.vars
.dev.vars.*

# OS / IDE
.DS_Store
.vscode/
.idea/
apps/web/.env
</file>

<file path=".repomixignore">
apps/api/.git/
*.svg
apps/api/worker-configuration.d.ts
packages/shared/dist/
</file>

<file path="apps/api/migrations/0004_phase2_seed_products.sql">
INSERT OR REPLACE INTO seed_meta (k, v) VALUES ('seed_products_version', 'phase2-v1');

INSERT OR REPLACE INTO products (
  upc, source, off_product_id, name, brand, quantity_value, quantity_unit,
  normalized_name, image_url, source_url, updated_at, raw_hash
) VALUES
(
  '0000000000001', 'seed', NULL,
  'Seed Whole Milk', 'Seed Brand',
  1.0, 'l',
  'seed brand seed whole milk',
  NULL, NULL,
  strftime('%s','now'),
  NULL
),
(
  '0000000000002', 'seed', NULL,
  'Seed Peanut Butter', 'Seed Brand',
  16.0, 'oz',
  'seed brand seed peanut butter',
  NULL, NULL,
  strftime('%s','now'),
  NULL
),
(
  '012345678905', 'seed', NULL,
  'Seed Honeycrisp Apples', 'Seed Brand',
  3.0, 'lb',
  'seed brand seed honeycrisp apples',
  NULL, NULL,
  strftime('%s','now'),
  NULL
);
</file>

<file path="apps/api/src/middleware/cors.ts">
import type { MiddlewareHandler } from "hono";

export function cors(allowedOrigin: string): MiddlewareHandler {
  return async (c, next) => {
    const origin = c.req.header("Origin") || "";
    if (origin && origin === allowedOrigin) {
      c.header("Access-Control-Allow-Origin", origin);
      c.header("Vary", "Origin");
      c.header("Access-Control-Allow-Headers", "content-type, x-pricecart-session");
      c.header("Access-Control-Allow-Methods", "GET, POST, PATCH, DELETE, OPTIONS");
    }

    if (c.req.method === "OPTIONS") {
      return c.body(null, 204);
    }

    await next();
  };
}
</file>

<file path="apps/api/src/services/pricing.ts">
import type { CartQuoteResponse, EvidenceType, FreshnessBucket, PriceSource } from "@pricecart/shared";
import { takeToken } from "../lib/rateLimit";
import { nowSec } from "../lib/time";
import { getKrogerLivePriceOverlay } from "./krogerLivePrices";

type EnvLike = {
  DB: D1Database;
  OUTBOUND_USER_AGENT?: string;
  OUTBOUND_REFERER?: string;

  KROGER_LIVE_PRICES_ENABLED?: string;
  KROGER_CLIENT_ID?: string;
  KROGER_CLIENT_SECRET?: string;
  KROGER_BASE_URL?: string;
  KROGER_TOKEN_URL?: string;
};

const RL_QUOTE = { capacity: 60, refillPerSec: 1 / 2, cost: 1 };   // ~60/min/session
const RL_SUBMIT = { capacity: 20, refillPerSec: 1 / 60, cost: 1 }; // ~20/min/session

type CartItemRow = { upc: string; quantity: number };

type StoreRow = { id: string; name: string; lat: number; lon: number; tags_json: string | null };

type PriceRow = {
  upc: string;
  price_cents: number;
  currency: string;
  observed_at: number;
  source: PriceSource;
  evidence_type: EvidenceType;
  confidence: number;
};

function clamp01(x: number): number {
  if (x < 0) return 0;
  if (x > 1) return 1;
  return x;
}

function freshnessBucket(now: number, observedAt: number): FreshnessBucket {
  const ageSec = Math.max(0, now - observedAt);
  const ageDays = ageSec / 86400;
  if (ageDays <= 2) return "fresh";
  if (ageDays <= 7) return "recent";
  if (ageDays <= 30) return "stale";
  return "old";
}

function adjustedTotal(total: number, completeness: number): number {
  // Penalize missing items. If completeness is low, the total is less trustworthy.
  // This keeps ranking honest: a store missing half the prices should not win by default.
  const denom = Math.max(0.25, completeness);
  return Math.round(total / denom);
}

function median(nums: number[]): number | null {
  if (nums.length === 0) return null;
  const a = [...nums].sort((x, y) => x - y);
  const mid = Math.floor(a.length / 2);
  return a.length % 2 === 1 ? a[mid] : Math.round((a[mid - 1] + a[mid]) / 2);
}

export async function quoteCart(
  env: EnvLike,
  input: { session_id: string; store_ids: string[] }
): Promise<CartQuoteResponse> {
  const ok = await takeToken(env.DB, `quote:${input.session_id}`, RL_QUOTE);
  if (!ok) throw new Error("RATE_LIMITED");

  const storeIds = Array.from(new Set(input.store_ids)).slice(0, 20);

  // Load cart items (server-backed)
  const cartRows = await env.DB.prepare(
    `SELECT upc, quantity
     FROM cart_items
     WHERE session_id = ?
     ORDER BY updated_at DESC`
  )
    .bind(input.session_id)
    .all<CartItemRow>();

  const cartItems = cartRows.results;
  const itemCount = cartItems.length;

  const t = nowSec();
  const warnings: string[] = [];

  if (itemCount === 0) {
    warnings.push("CART_EMPTY");
  }

  // Load store names
  const storePlaceholders = storeIds.map(() => "?").join(",");
  const storeRows = await env.DB.prepare(
    `SELECT id, name, lat, lon, tags_json FROM stores WHERE id IN (${storePlaceholders})`
  )
    .bind(...storeIds)
    .all<StoreRow>();

  const storesById = new Map(storeRows.results.map((s) => [s.id, s]));
  const resolvedStoreIds = storeIds.filter((id) => storesById.has(id));
  const missingStores = storeIds.filter((id) => !storesById.has(id));
  if (missingStores.length) warnings.push(`UNKNOWN_STORES:${missingStores.join(",")}`);

  const upcs = cartItems.map((c) => c.upc);

  const outStores = [] as CartQuoteResponse["stores"];

  for (const store_id of resolvedStoreIds) {
    const store = storesById.get(store_id)!;

    const priceMap = new Map<string, PriceRow>();

    if (upcs.length > 0) {
      const inPlaceholders = upcs.map(() => "?").join(",");
      // Window function: pick the best row per UPC by observed_at then confidence
      const rows = await env.DB.prepare(
        `SELECT upc, price_cents, currency, observed_at, source, evidence_type, confidence
         FROM (
           SELECT
             upc, price_cents, currency, observed_at, source, evidence_type, confidence,
             ROW_NUMBER() OVER (PARTITION BY upc ORDER BY observed_at DESC, confidence DESC) AS rn
           FROM price_snapshots
           WHERE store_id = ? AND upc IN (${inPlaceholders})
         )
         WHERE rn = 1`
      )
        .bind(store_id, ...upcs)
        .all<PriceRow>();

      for (const r of rows.results) priceMap.set(r.upc, r);

      
    }
    
    // Optional live-price overlay (Phase 5). Default off via env flag.
    const overlay = await getKrogerLivePriceOverlay(env, {
      session_id: input.session_id,
      store: { id: store_id, name: store.name, lat: store.lat, lon: store.lon, tags: store.tags_json ? JSON.parse(store.tags_json) : {} },
      upcs,
      t
    });
    if (overlay.warnings.length) warnings.push(...overlay.warnings);

    // Overwrite snapshot prices with live prices when available
    if (overlay.prices_by_upc.size) {
      for (const [upc, live] of overlay.prices_by_upc) {
        priceMap.set(upc, {
          upc,
          price_cents: live.price_cents,
          currency: "USD",
          observed_at: live.observed_at,
          source: "kroger",
          evidence_type: "dataset",
          confidence: live.confidence
        });
      }
    }



    let total = 0;
    let matched = 0;
    let missing = 0;

    const lines = cartItems.map((it) => {
      const p = priceMap.get(it.upc);
      if (!p) {
        missing += 1;
        return {
          upc: it.upc,
          quantity: it.quantity,
          unit_price_cents: null,
          extended_price_cents: null,
          missing: true,
          observed_at: null,
          source: null,
          evidence_type: null,
          confidence: null,
          freshness: null
        };
      }

      matched += 1;
      const ext = p.price_cents * it.quantity;
      total += ext;

      return {
        upc: it.upc,
        quantity: it.quantity,
        unit_price_cents: p.price_cents,
        extended_price_cents: ext,
        missing: false,
        observed_at: p.observed_at,
        source: p.source,
        evidence_type: p.evidence_type,
        confidence: clamp01(p.confidence),
        freshness: freshnessBucket(t, p.observed_at)
      };
    });

    const completeness = itemCount === 0 ? 0 : matched / itemCount;

    outStores.push({
      store_id,
      store_name: store.name,
      currency: "USD",
      item_count: itemCount,
      matched_count: matched,
      missing_count: missing,
      completeness,
      total_cents: total,
      adjusted_total_cents: adjustedTotal(total, completeness),
      lines
    });
  }

  // Choose cheapest: prefer higher completeness, then lower adjusted total
  const ranked = [...outStores].sort((a, b) => {
    if (a.completeness !== b.completeness) return b.completeness - a.completeness;
    if (a.adjusted_total_cents !== b.adjusted_total_cents) return a.adjusted_total_cents - b.adjusted_total_cents;
    return a.total_cents - b.total_cents;
  });

  const cheapest = ranked.length ? ranked[0] : null;

  return {
    session_id: input.session_id,
    generated_at: t,
    currency: "USD",
    cheapest_store_id: cheapest ? cheapest.store_id : null,
    stores: outStores,
    warnings
  };
}

export async function submitPrice(
  env: EnvLike,
  input: {
    session_id: string;
    store_id: string;
    upc: string;
    price_cents: number;
    currency: string;
    observed_at?: number;
    evidence_type: EvidenceType;
  }
): Promise<{ snapshot_id: string }> {
  const ok = await takeToken(env.DB, `price_submit:${input.session_id}`, RL_SUBMIT);
  if (!ok) throw new Error("RATE_LIMITED");

  // Store must exist
  const store = await env.DB.prepare("SELECT id FROM stores WHERE id = ?")
    .bind(input.store_id)
    .first<{ id: string }>();
  if (!store) throw new Error("STORE_NOT_FOUND");

  // Product must exist
  const prod = await env.DB.prepare("SELECT upc FROM products WHERE upc = ?")
    .bind(input.upc)
    .first<{ upc: string }>();
  if (!prod) throw new Error("PRODUCT_NOT_FOUND");

  const t = nowSec();
  const observedAt = input.observed_at ?? t;

  // Basic time sanity: allow small clock skew, but block far-future timestamps
  if (observedAt > t + 86400) throw new Error("OBSERVED_AT_IN_FUTURE");

  // Dedupe identical spam: same price within 1 hour
  const dup = await env.DB.prepare(
    `SELECT id FROM price_snapshots
     WHERE store_id = ? AND upc = ? AND price_cents = ?
       AND ABS(observed_at - ?) <= 3600
     LIMIT 1`
  )
    .bind(input.store_id, input.upc, input.price_cents, observedAt)
    .first<{ id: string }>();

  if (dup?.id) return { snapshot_id: dup.id };

  // Outlier check vs median recent history for this store+UPC
  const hist = await env.DB.prepare(
    `SELECT price_cents FROM price_snapshots
     WHERE store_id = ? AND upc = ?
     ORDER BY observed_at DESC
     LIMIT 25`
  )
    .bind(input.store_id, input.upc)
    .all<{ price_cents: number }>();

  const med = median(hist.results.map((r) => r.price_cents));
  if (med !== null) {
    if (input.price_cents < Math.floor(med * 0.3) || input.price_cents > Math.ceil(med * 3.0)) {
      throw new Error("OUTLIER_PRICE");
    }
  }

  const confidenceBase = input.evidence_type === "receipt_text" ? 0.6 : 0.45;
  const confidence = clamp01(confidenceBase);

  const id = crypto.randomUUID();

  await env.DB.prepare(
    `INSERT INTO price_snapshots (
      id, store_id, upc, price_cents, currency, observed_at, source, evidence_type,
      confidence, submitter_session_id, flags_json, created_at
    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`
  )
    .bind(
      id,
      input.store_id,
      input.upc,
      input.price_cents,
      input.currency,
      observedAt,
      "community",
      input.evidence_type,
      confidence,
      input.session_id,
      null,
      t
    )
    .run();

  return { snapshot_id: id };
}
</file>

<file path="apps/api/src/env.ts">
export type Env = {
  DB: D1Database;

  // Existing outbound headers (used by external providers)
  OUTBOUND_USER_AGENT?: string;
  OUTBOUND_REFERER?: string;

  // Open Food Facts
  OFF_BASE_URL?: string; // optional, defaults to https://world.openfoodfacts.org

  // Phase 5  Kroger live prices (optional, default OFF)
  KROGER_LIVE_PRICES_ENABLED?: string; // "1" enables live price overlay
  KROGER_CLIENT_ID?: string; // secret
  KROGER_CLIENT_SECRET?: string; // secret
  KROGER_BASE_URL?: string; // optional, default "https://api.kroger.com/v1"
  KROGER_TOKEN_URL?: string; // optional, default "https://api.kroger.com/v1/connect/oauth2/token"
};
</file>

<file path="apps/api/vite.config.ts">
import react from "@vitejs/plugin-react";
import { defineConfig } from "vite";

// https://vite.dev/config/
export default defineConfig(async ({ mode }) => {
  // Vitest runs Vite in "test" mode and sets VITEST in the config process env.
  const isVitest = !!process.env.VITEST || mode === "test";
  const plugins = [react()];

  if (!isVitest) {
    const { cloudflare } = await import("@cloudflare/vite-plugin");
    plugins.push(cloudflare());
  }

  return { plugins };
});
</file>

<file path="apps/web/.env.example">
VITE_API_BASE_URL=http://localhost:8787
VITE_API_BASE_URL=http://localhost:8787/api
</file>

<file path="apps/web/package.json">
{
  "name": "web",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview",
    "test": "vitest run"
  },
  "dependencies": {
    "@pricecart/shared": "file:../../packages/shared",
    "leaflet": "1.9.4",
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "react-leaflet": "5.0.0"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "@types/leaflet": "1.9.21",
    "@types/node": "^24.10.1",
    "@types/react": "^19.2.5",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.1",
    "eslint": "^9.39.1",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.24",
    "globals": "^16.5.0",
    "typescript": "~5.9.3",
    "typescript-eslint": "^8.46.4",
    "vite": "^7.2.4",
    "vitest": "^4.0.16"
  }
}
</file>

<file path="package.json">
{
  "name": "pricecart",
  "private": true,
  "workspaces": [
    "apps/*",
    "packages/*"
  ],
  "scripts": {
    "dev": "npm run -ws --if-present dev",
    "test": "npm run -ws --if-present test",
    "lint": "npm run -ws --if-present lint",
    "typecheck": "npm run -ws --if-present typecheck",
    "build": "npm run -ws --if-present build"
  },
  "dependencies": {
    "hono": "4.11.3",
    "zod": "4.2.1"
  },
  "devDependencies": {
    "@cloudflare/workers-types": "4.20251225.0",
    "@cloudflare/vite-plugin": "1.19.0",
    "@types/node": "25.0.3",
    "miniflare": "4.20251217.0",
    "vitest": "4.0.16"
  }
}
</file>

<file path="apps/api/src/index.ts">
import { CartAddItemRequestSchema, CartQuoteRequestSchema, CartSetItemRequestSchema, PriceSubmitRequestSchema } from "@pricecart/shared";
import { Hono } from "hono";
import { z } from "zod";
import type { Env } from "./env";
import { cors } from "./middleware/cors";
import { securityHeaders } from "./middleware/security";
import { addCartItem, clearCart, getCart, removeCartItem, setCartItemQuantity } from "./services/cart";
import { quoteCart, submitPrice } from "./services/pricing";
import { productSearch } from "./services/productSearch";
import { storeSearch } from "./services/storeDiscovery";

const app = new Hono<{ Bindings: Env }>();

// Adjust to your Pages domain once known
const ALLOWED_ORIGIN = "http://localhost:5173";

app.use("*", securityHeaders());
app.use("*", cors(ALLOWED_ORIGIN));

app.get("/health", (c) => c.json({ ok: true }));
const SessionIdSchema = z.string().min(1).max(128);

function requireSession(c: any): string {
  const raw = c.req.header("x-pricecart-session");
  const parsed = SessionIdSchema.safeParse(raw);
  if (!parsed.success) throw new Error("MISSING_SESSION");
  return parsed.data;
}



const StoreSearchQuery = z.object({
  location: z.string().min(2).max(200),
  radius_m: z.coerce.number().int().positive().optional(),
  page: z.coerce.number().int().min(1).optional(),
  page_size: z.coerce.number().int().min(1).max(50).optional()
});

const ProductSearchQuery = z.object({
  q: z.string().min(2).max(200),
  page: z.coerce.number().int().min(1).optional(),
  page_size: z.coerce.number().int().min(1).max(50).optional()
});

function slicePage<T>(items: T[], page: number, pageSize: number): T[] {
  const start = (page - 1) * pageSize;
  return items.slice(start, start + pageSize);
}

app.get("/stores/search", async (c) => {
  const parsed = StoreSearchQuery.safeParse({
    location: c.req.query("location"),
    radius_m: c.req.query("radius_m"),
    page: c.req.query("page"),
    page_size: c.req.query("page_size")
  });

  if (!parsed.success) {
    return c.json({ error: "INVALID_INPUT", details: parsed.error.flatten() }, 400);
  }

  const sessionId = c.req.header("x-pricecart-session") || "anon";
  const page = parsed.data.page ?? 1;
  const pageSize = parsed.data.page_size ?? 20;

  try {
    const res = await storeSearch(c.env, {
      location: parsed.data.location,
      radius_m: parsed.data.radius_m ?? 5000,
      session_id: sessionId
    });

    const totalCount = res.stores.length;
    const stores = slicePage(res.stores, page, pageSize);

    console.log(
      JSON.stringify({
        level: "info",
        route: "/stores/search",
        session: sessionId,
        data_mode: res.data_mode,
        radius_m: res.radius_m,
        page,
        page_size: pageSize,
        store_count: stores.length,
        total_count: totalCount
      })
    );

    return c.json({
      ...res,
      stores,
      page,
      page_size: pageSize,
      total_count: totalCount
    });
  } catch (e: unknown) {
    const msg = e instanceof Error ? e.message : String(e);

    if (msg.includes("RATE_LIMIT")) return c.json({ error: "RATE_LIMITED" }, 429);
    if (msg.includes("NOT_FOUND")) return c.json({ error: "NOT_FOUND" }, 404);

    console.log(
      JSON.stringify({
        level: "error",
        route: "/stores/search",
        session: sessionId,
        message: "store search failed",
        err: msg
      })
    );

    return c.json({ error: "INTERNAL_ERROR" }, 500);
  }
});

app.get("/products/search", async (c) => {
  const parsed = ProductSearchQuery.safeParse({
    q: c.req.query("q"),
    page: c.req.query("page"),
    page_size: c.req.query("page_size")
  });

  if (!parsed.success) {
    return c.json({ error: "INVALID_INPUT", details: parsed.error.flatten() }, 400);
  }

  const sessionId = c.req.header("x-pricecart-session") || "anon";
  const page = parsed.data.page ?? 1;
  const pageSize = parsed.data.page_size ?? 10;

  try {
    const res = await productSearch(c.env, {
      q: parsed.data.q,
      page,
      page_size: pageSize,
      session_id: sessionId
    });

    console.log(
      JSON.stringify({
        level: "info",
        route: "/products/search",
        session: sessionId,
        q: parsed.data.q,
        page,
        page_size: pageSize,
        product_count: res.products.length,
        total_count: res.total_count
      })
    );

    return c.json(res);
  } catch (e: unknown) {
    const msg = e instanceof Error ? e.message : String(e);

    if (msg.includes("RATE_LIMIT")) return c.json({ error: "RATE_LIMITED" }, 429);

    console.log(
      JSON.stringify({
        level: "error",
        route: "/products/search",
        session: sessionId,
        message: "product search failed",
        err: msg
      })
    );

    return c.json({ error: "INTERNAL_ERROR" }, 500);
  }
});

app.get("/cart", async (c) => {
  try {
    const session_id = requireSession(c);
    const cart = await getCart(c.env, session_id);
    return c.json(cart);
  } catch (err) {
    const msg = err instanceof Error ? err.message : String(err);
    return c.json(
      { error: msg === "MISSING_SESSION" ? "MISSING_SESSION" : "INTERNAL_ERROR" },
      msg === "MISSING_SESSION" ? 401 : 500
    );
  }
});

app.post("/cart/items", async (c) => {
  try {
    const session_id = requireSession(c);
    const body = await c.req.json();
    const parsed = CartAddItemRequestSchema.safeParse(body);
    if (!parsed.success) return c.json({ error: "INVALID_INPUT" }, 400);

    const cart = await addCartItem(c.env, { session_id, ...parsed.data });
    return c.json(cart);
  } catch (err) {
    const msg = err instanceof Error ? err.message : String(err);
    if (msg === "MISSING_SESSION") return c.json({ error: "MISSING_SESSION" }, 401);
    if (msg === "PRODUCT_NOT_FOUND") return c.json({ error: "PRODUCT_NOT_FOUND" }, 404);
    if (msg === "CART_TOO_LARGE") return c.json({ error: "CART_TOO_LARGE" }, 413);
    if (msg === "QUANTITY_TOO_LARGE") return c.json({ error: "QUANTITY_TOO_LARGE" }, 400);
    if (msg === "RATE_LIMITED") return c.json({ error: "RATE_LIMITED" }, 429);
    return c.json({ error: "INTERNAL_ERROR" }, 500);
  }
});

app.patch("/cart/items/:upc", async (c) => {
  try {
    const session_id = requireSession(c);
    const upc = c.req.param("upc");
    const body = await c.req.json();
    const parsed = CartSetItemRequestSchema.safeParse(body);
    if (!parsed.success) return c.json({ error: "INVALID_INPUT" }, 400);

    const cart = await setCartItemQuantity(c.env, { session_id, upc, quantity: parsed.data.quantity });
    return c.json(cart);
  } catch (err) {
    const msg = err instanceof Error ? err.message : String(err);
    if (msg === "MISSING_SESSION") return c.json({ error: "MISSING_SESSION" }, 401);
    if (msg === "QUANTITY_TOO_LARGE") return c.json({ error: "QUANTITY_TOO_LARGE" }, 400);
    if (msg === "RATE_LIMITED") return c.json({ error: "RATE_LIMITED" }, 429);
    return c.json({ error: "INTERNAL_ERROR" }, 500);
  }
});

app.delete("/cart/items/:upc", async (c) => {
  try {
    const session_id = requireSession(c);
    const upc = c.req.param("upc");
    const cart = await removeCartItem(c.env, { session_id, upc });
    return c.json(cart);
  } catch (err) {
    const msg = err instanceof Error ? err.message : String(err);
    if (msg === "MISSING_SESSION") return c.json({ error: "MISSING_SESSION" }, 401);
    if (msg === "RATE_LIMITED") return c.json({ error: "RATE_LIMITED" }, 429);
    return c.json({ error: "INTERNAL_ERROR" }, 500);
  }
});

app.post("/cart/clear", async (c) => {
  try {
    const session_id = requireSession(c);
    const cart = await clearCart(c.env, session_id);
    return c.json(cart);
  } catch (err) {
    const msg = err instanceof Error ? err.message : String(err);
    if (msg === "MISSING_SESSION") return c.json({ error: "MISSING_SESSION" }, 401);
    if (msg === "RATE_LIMITED") return c.json({ error: "RATE_LIMITED" }, 429);
    return c.json({ error: "INTERNAL_ERROR" }, 500);
  }
});

app.post("/cart/quote", async (c) => {
  try {
    const session_id = requireSession(c);
    const body = await c.req.json();
    const parsed = CartQuoteRequestSchema.safeParse(body);
    if (!parsed.success) return c.json({ error: "INVALID_INPUT" }, 400);

    const res = await quoteCart(c.env, { session_id, store_ids: parsed.data.store_ids });

    console.log(
      JSON.stringify({
        level: "info",
        route: "/cart/quote",
        session: session_id,
        store_count: parsed.data.store_ids.length,
        cheapest_store_id: res.cheapest_store_id,
        warnings: res.warnings
      })
    );

    return c.json(res);
  } catch (err) {
    const msg = err instanceof Error ? err.message : String(err);
    if (msg === "MISSING_SESSION") return c.json({ error: "MISSING_SESSION" }, 401);
    if (msg === "RATE_LIMITED") return c.json({ error: "RATE_LIMITED" }, 429);
    return c.json({ error: "INTERNAL_ERROR" }, 500);
  }
});

app.post("/prices/submit", async (c) => {
  try {
    const session_id = requireSession(c);
    const body = await c.req.json();
    const parsed = PriceSubmitRequestSchema.safeParse(body);
    if (!parsed.success) return c.json({ error: "INVALID_INPUT" }, 400);

    const out = await submitPrice(c.env, {
      session_id,
      store_id: parsed.data.store_id,
      upc: parsed.data.upc,
      price_cents: parsed.data.price_cents,
      currency: parsed.data.currency,
      observed_at: parsed.data.observed_at,
      evidence_type: parsed.data.evidence_type
    });

    console.log(
      JSON.stringify({
        level: "info",
        route: "/prices/submit",
        session: session_id,
        store_id: parsed.data.store_id,
        upc: parsed.data.upc,
        price_cents: parsed.data.price_cents,
        snapshot_id: out.snapshot_id
      })
    );

    return c.json({ ok: true, snapshot_id: out.snapshot_id });
  } catch (err) {
    const msg = err instanceof Error ? err.message : String(err);
    if (msg === "MISSING_SESSION") return c.json({ error: "MISSING_SESSION" }, 401);
    if (msg === "RATE_LIMITED") return c.json({ error: "RATE_LIMITED" }, 429);
    if (msg === "STORE_NOT_FOUND") return c.json({ error: "STORE_NOT_FOUND" }, 404);
    if (msg === "PRODUCT_NOT_FOUND") return c.json({ error: "PRODUCT_NOT_FOUND" }, 404);
    if (msg === "OUTLIER_PRICE") return c.json({ error: "OUTLIER_PRICE" }, 422);
    if (msg === "OBSERVED_AT_IN_FUTURE") return c.json({ error: "OBSERVED_AT_IN_FUTURE" }, 400);
    return c.json({ error: "INTERNAL_ERROR" }, 500);
  }
});

export default app;
</file>

<file path="apps/web/src/lib/api.ts">
import type {
  Cart,
  CartAddItemRequest,
  CartQuoteRequest,
  CartQuoteResponse,
  CartSetItemRequest,
  PriceSubmitRequest,
  PriceSubmitResponse,
  ProductLookupResponse,
  ProductSearchResponse,
  StoreSearchResponse
} from "@pricecart/shared";
import { getSessionId } from "./session";

type FetchJsonInit = Omit<RequestInit, "body"> & { json?: unknown };

function apiBase(): string {
  // Recommended dev value: http://localhost:8787/api
  return (import.meta as any).env?.VITE_API_BASE_URL ?? "http://localhost:8787/api";
}

async function fetchJson<T>(url: string, init: FetchJsonInit = {}): Promise<T> {
  const headers = new Headers(init.headers);
  headers.set("x-pricecart-session", getSessionId());

  let body: BodyInit | undefined = undefined;
  if (init.json !== undefined) {
    headers.set("content-type", "application/json");
    body = JSON.stringify(init.json);
  }

  const res = await fetch(url, { ...init, headers, body });

  if (!res.ok) {
    const payload = await res.json().catch(() => ({}));
    throw new Error(payload?.error || `HTTP_${res.status}`);
  }

  return (await res.json()) as T;
}

export async function fetchStores(params: { location: string; radius_m?: number }): Promise<StoreSearchResponse> {
  const base = apiBase();
  const url = new URL(base + "/stores/search");
  url.searchParams.set("location", params.location);
  url.searchParams.set("radius_m", String(params.radius_m ?? 1500));
  return fetchJson<StoreSearchResponse>(url.toString());
}

export async function lookupProductByUpc(upc: string): Promise<ProductLookupResponse> {
  const base = apiBase();
  const url = new URL(base + `/products/lookup/${encodeURIComponent(upc)}`);
  return fetchJson<ProductLookupResponse>(url.toString());
}

export async function searchProducts(params: { q: string; page?: number; page_size?: number }): Promise<ProductSearchResponse> {
  const base = apiBase();
  const url = new URL(base + "/products/search");
  url.searchParams.set("q", params.q);
  url.searchParams.set("page", String(params.page ?? 1));
  url.searchParams.set("page_size", String(params.page_size ?? 10));
  return fetchJson<ProductSearchResponse>(url.toString());
}

// -------------------------
// Phase 3: Cart
// -------------------------

export async function getCart(): Promise<Cart> {
  const base = apiBase();
  const url = new URL(base + "/cart");
  return fetchJson<Cart>(url.toString());
}

export async function addCartItem(req: CartAddItemRequest): Promise<Cart> {
  const base = apiBase();
  const url = new URL(base + "/cart/items");
  return fetchJson<Cart>(url.toString(), { method: "POST", json: req });
}

export async function setCartItem(upc: string, req: CartSetItemRequest): Promise<Cart> {
  const base = apiBase();
  const url = new URL(base + `/cart/items/${encodeURIComponent(upc)}`);
  return fetchJson<Cart>(url.toString(), { method: "PATCH", json: req });
}

export async function removeCartItem(upc: string): Promise<Cart> {
  const base = apiBase();
  const url = new URL(base + `/cart/items/${encodeURIComponent(upc)}`);
  return fetchJson<Cart>(url.toString(), { method: "DELETE" });
}

export async function clearCart(): Promise<Cart> {
  const base = apiBase();
  const url = new URL(base + "/cart/clear");
  return fetchJson<Cart>(url.toString(), { method: "POST", json: {} });
}

export async function quoteCart(req: CartQuoteRequest): Promise<CartQuoteResponse> {
  const base = apiBase();
  const url = new URL(base + "/cart/quote");
  return fetchJson<CartQuoteResponse>(url.toString(), { method: "POST", json: req });
}

export async function submitPrice(req: PriceSubmitRequest): Promise<PriceSubmitResponse> {
  const base = apiBase();
  const url = new URL(base + "/prices/submit");
  return fetchJson<PriceSubmitResponse>(url.toString(), { method: "POST", json: req });
}
</file>

<file path="packages/shared/src/index.ts">
export * from "./cart.js";
export * from "./pricing.js";
export * from "./product.js";
export * from "./store.js";
</file>

<file path="apps/web/src/App.tsx">
import type { CartLine, CartQuoteResponse, Product, ProductLookupResponse, ProductSearchResponse, StoreSearchResponse } from "@pricecart/shared";
import "leaflet/dist/leaflet.css";
import { useMemo, useState } from "react";
import { MapContainer, Marker, Popup, TileLayer } from "react-leaflet";
import { fetchStores, lookupProductByUpc, quoteCart, searchProducts, submitPrice } from "./lib/api";
import { useCart } from "./lib/cart";

function formatErrorMessage(err: unknown) {
  return err instanceof Error ? err.message : String(err);
}

function qtyLabel(p: { quantity?: { raw: string | null; value: number | null; unit: string | null } | null }) {
  const q = p.quantity;
  if (!q) return "";
  if (q.raw) return q.raw;
  if (q.value && q.unit) return `${q.value} ${q.unit}`;
  return "";
}

function formatObservedAt(observedAt: number | null | undefined) {
  if (!observedAt) return "";
  try {
    return new Date(observedAt * 1000).toLocaleString();
  } catch {
    return "";
  }
}

function sourceLabel(source: string | null | undefined) {
  if (source === "kroger") return "Live price (Kroger)";
  if (source === "open_prices") return "Dataset (Open Prices)";
  if (source === "community") return "Community";
  if (source === "seed") return "Seed";
  return "";
}

export default function App() {
  const [view, setView] = useState<"stores" | "products" | "cart">("stores");

  // Phase 1: Stores
  const [location, setLocation] = useState("10001");
  const [radius, setRadius] = useState(1500);
  const [stores, setStores] = useState<StoreSearchResponse | null>(null);
  const [sStatus, setSStatus] = useState<string>("");

  // Phase 2: Products
  const [upc, setUpc] = useState("");
  const [lookup, setLookup] = useState<ProductLookupResponse | null>(null);
  const [q, setQ] = useState("");
  const [search, setSearch] = useState<ProductSearchResponse | null>(null);
  const [pStatus, setPStatus] = useState<string>("");

  // Phase 3: Cart
  const cart = useCart();
  const cartItemByUpc = useMemo(() => {
    const m = new Map<string, CartLine>();
    for (const it of cart.cart?.items ?? []) m.set(it.upc, it);
    return m;
  }, [cart.cart]);
  const [quote, setQuote] = useState<CartQuoteResponse | null>(null);
  const [quoteStatus, setQuoteStatus] = useState<string>("");
  const [submitStoreId, setSubmitStoreId] = useState<string>("");
  const [submitUpc, setSubmitUpc] = useState<string>("");
  const [submitPriceCents, setSubmitPriceCents] = useState<number>(0);
  const [submitStatus, setSubmitStatus] = useState<string>("");

  const mapCenter = useMemo(() => {
    const first = stores?.stores?.[0];
    return first ? { lat: first.lat, lon: first.lon } : { lat: 40.7484, lon: -73.9967 }; // Midtown fallback
  }, [stores]);

  async function onSearchStores() {
    setSStatus("Loading...");
    setStores(null);
    try {
      const res = await fetchStores({ location, radius_m: radius });
      setStores(res);
      setSStatus("");
    } catch (err) {
      setSStatus(formatErrorMessage(err));
    }
  }

  async function onLookupUpc() {
    setPStatus("Loading...");
    setLookup(null);
    try {
      const res = await lookupProductByUpc(upc.trim());
      setLookup(res);
      setPStatus("");
    } catch (err) {
      setPStatus(formatErrorMessage(err));
    }
  }

  async function onSearchProducts() {
    setPStatus("Loading...");
    setSearch(null);
    try {
      const res = await searchProducts({ q: q.trim(), page: 1, page_size: 10 });
      setSearch(res);
      setPStatus("");
    } catch (err) {
      setPStatus(formatErrorMessage(err));
    }
  }

  async function addProductToCart(p: Product) {
    await cart.add(p.upc, 1);
    setView("cart");
  }

  async function onComparePrices() {
    setQuoteStatus("Loading...");
    setQuote(null);

    try {
      const storeIds = (stores?.stores ?? []).slice(0, 3).map((s) => s.id);
      if (storeIds.length === 0) {
        setQuoteStatus("Search stores first (Phase 1). Then compare.");
        return;
      }

      const res = await quoteCart({ store_ids: storeIds });
      setQuote(res);
      setQuoteStatus("");

      // helpful default for submission UI
      setSubmitStoreId(storeIds[0] ?? "");
    } catch (err) {
      setQuoteStatus(formatErrorMessage(err));
    }
  }

  async function onSubmitPrice() {
    setSubmitStatus("Submitting...");
    try {
      await submitPrice({
        store_id: submitStoreId,
        upc: submitUpc.trim(),
        price_cents: submitPriceCents,
        currency: "USD",
        evidence_type: "manual"
      });

      setSubmitStatus("Saved. Re-run compare to see updates.");
    } catch (err) {
      setSubmitStatus(formatErrorMessage(err));
    }
  }

  return (
    <div style={{ maxWidth: 980, margin: "0 auto", padding: 16 }}>
      <header style={{ display: "flex", gap: 8, alignItems: "center", justifyContent: "space-between" }}>
        <h2 style={{ margin: 0 }}>PriceCart</h2>
        <nav style={{ display: "flex", gap: 8 }}>
          <button onClick={() => setView("stores")} disabled={view === "stores"}>
            Stores
          </button>
          <button onClick={() => setView("products")} disabled={view === "products"}>
            Products
          </button>
          <button onClick={() => setView("cart")} disabled={view === "cart"}>
            Cart {cart.cart ? `(${cart.cart.item_count})` : ""}
          </button>
        </nav>
      </header>

      <hr />

      {view === "stores" && (
        <section>
          <h3>Find nearby stores</h3>
          <div style={{ display: "flex", gap: 8, alignItems: "center", flexWrap: "wrap" }}>
            <label>
              Location
              <input value={location} onChange={(e) => setLocation(e.target.value)} style={{ marginLeft: 8 }} />
            </label>
            <label>
              Radius (m)
              <input
                type="number"
                value={radius}
                onChange={(e) => setRadius(Number(e.target.value))}
                style={{ marginLeft: 8, width: 120 }}
              />
            </label>
            <button onClick={onSearchStores}>Search</button>
          </div>

          {sStatus && <p>{sStatus}</p>}

          {stores && (
            <>
              <p>
                Data: <b>{stores.data_mode}</b>
              </p>

              <div style={{ height: 360, borderRadius: 12, overflow: "hidden", border: "1px solid #ddd" }}>
                <MapContainer center={[mapCenter.lat, mapCenter.lon]} zoom={14} style={{ height: "100%" }}>
                  <TileLayer attribution="&copy; OpenStreetMap" url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png" />
                  {stores.stores.map((s) => (
                    <Marker key={s.id} position={[s.lat, s.lon]}>
                      <Popup>
                        <b>{s.name}</b>
                        <div>{Math.round(s.distance_m)}m away</div>
                      </Popup>
                    </Marker>
                  ))}
                </MapContainer>
              </div>

              <h4>Results</h4>
              <ul>
                {stores.stores.map((s) => (
                  <li key={s.id}>
                    <b>{s.name}</b> - {Math.round(s.distance_m)}m
                  </li>
                ))}
              </ul>

              <small>
                {stores.attribution.text} {stores.attribution.links.map((l) => (
                  <a key={l.href} href={l.href} target="_blank" rel="noreferrer" style={{ marginLeft: 8 }}>
                    {l.label}
                  </a>
                ))}
              </small>
            </>
          )}
        </section>
      )}

      {view === "products" && (
        <section>
          <h3>Find products</h3>

          <div style={{ display: "grid", gap: 12 }}>
            <div style={{ display: "flex", gap: 8, alignItems: "center", flexWrap: "wrap" }}>
              <label>
                UPC
                <input value={upc} onChange={(e) => setUpc(e.target.value)} style={{ marginLeft: 8 }} />
              </label>
              <button onClick={onLookupUpc}>Lookup</button>
              {lookup?.product && (
                <button onClick={() => addProductToCart(lookup.product)}>Add to cart</button>
              )}
            </div>

            {lookup && (
              <div style={{ padding: 12, border: "1px solid #ddd", borderRadius: 12 }}>
                <b>{lookup.product.name}</b>
                <div>{lookup.product.brand ?? ""}</div>
                <div style={{ opacity: 0.8 }}>{qtyLabel(lookup.product)}</div>
              </div>
            )}

            <div style={{ display: "flex", gap: 8, alignItems: "center", flexWrap: "wrap" }}>
              <label>
                Search
                <input value={q} onChange={(e) => setQ(e.target.value)} style={{ marginLeft: 8, width: 260 }} />
              </label>
              <button onClick={onSearchProducts}>Search</button>
            </div>

            {pStatus && <p>{pStatus}</p>}

            {search && (
              <>
                <p>
                  Results: <b>{search.total}</b>
                </p>
                <ul style={{ display: "grid", gap: 8, paddingLeft: 16 }}>
                  {search.products.map((p) => (
                    <li key={p.upc} style={{ display: "flex", gap: 8, alignItems: "center" }}>
                      <span style={{ flex: 1 }}>
                        <b>{p.name}</b> {p.brand ? <span style={{ opacity: 0.8 }}>({p.brand})</span> : null}
                      </span>
                      <button onClick={() => cart.add(p.upc, 1)}>Add</button>
                    </li>
                  ))}
                </ul>
              </>
            )}
          </div>
        </section>
      )}

      {view === "cart" && (
        <section>
          <h3>Your cart</h3>

          {cart.status === "loading" && <p>Loading...</p>}
          {cart.status === "error" && <p>Error: {cart.error}</p>}

          {cart.cart && cart.cart.item_count === 0 && <p>Your cart is empty. Add items from the Products tab.</p>}

          {cart.cart && cart.cart.item_count > 0 && (
            <>
              <p>
                Items: <b>{cart.cart.item_count}</b> | Total units: <b>{cart.cart.total_units}</b>
              </p>

              <ul style={{ display: "grid", gap: 12, paddingLeft: 16 }}>
                {cart.cart.items.map((it) => (
                  <li key={it.upc} style={{ display: "grid", gridTemplateColumns: "1fr auto", gap: 8 }}>
                    <div>
                      <b>{it.name}</b>
                      <div style={{ opacity: 0.8 }}>
                        {it.brand ?? ""} {it.quantity?.value && it.quantity?.unit ? `- ${it.quantity.value} ${it.quantity.unit}` : ""}
                      </div>
                      <div style={{ opacity: 0.7, fontSize: 12 }}>{it.upc}</div>
                    </div>

                    <div style={{ display: "flex", gap: 8, alignItems: "center", justifyContent: "flex-end" }}>
                      <button onClick={() => cart.setQuantity(it.upc, Math.max(1, it.count - 1))} aria-label="Decrease">
                        -
                      </button>
                      <input
                        type="number"
                        min={1}
                        max={99}
                        value={it.count}
                        onChange={(e) => cart.setQuantity(it.upc, Math.max(1, Math.min(99, Number(e.target.value) || 1)))}
                        style={{ width: 64 }}
                      />
                      <button onClick={() => cart.setQuantity(it.upc, Math.min(99, it.count + 1))} aria-label="Increase">
                        +
                      </button>
                      <button onClick={() => cart.remove(it.upc)}>Remove</button>
                    </div>
                  </li>
                ))}
              </ul>

              <div style={{ display: "flex", gap: 8, marginTop: 12 }}>
                <button onClick={cart.clear}>Clear cart</button>
                <button onClick={onComparePrices}>Compare prices</button>
              </div>

              {quoteStatus && <p>{quoteStatus}</p>}

              {quote && (
                <div style={{ marginTop: 16, padding: 12, border: "1px solid #ddd", borderRadius: 12 }}>
                  <h4 style={{ marginTop: 0 }}>Price comparison</h4>

                  {quote.cheapest_store_id ? (
                    <p>
                      Cheapest (by completeness, then adjusted total): <b>{quote.cheapest_store_id}</b>
                    </p>
                  ) : null}

                  {quote.warnings?.length ? (
                    <p style={{ opacity: 0.8 }}>
                      Warnings: {quote.warnings.join(", ")}
                    </p>
                  ) : null}

                  <ul style={{ display: "grid", gap: 12, paddingLeft: 16 }}>
                    {[...quote.stores]
                      .sort((a, b) => a.adjusted_total_cents - b.adjusted_total_cents)
                      .map((s) => (
                        <li key={s.store_id}>
                          <b>{s.store_name}</b> ({s.store_id})
                          <div>
                            Total: <b>${(s.total_cents / 100).toFixed(2)}</b> | Missing: <b>{s.missing_count}</b> | Completeness:{" "}
                            <b>{Math.round(s.completeness * 100)}%</b>
                          </div>
                          <div style={{ opacity: 0.8 }}>
                            Adjusted total: <b>${(s.adjusted_total_cents / 100).toFixed(2)}</b>
                          </div>
                          <details style={{ marginTop: 8 }}>
                            <summary>Line items</summary>
                            <ul style={{ paddingLeft: 16, marginTop: 8, display: "grid", gap: 6 }}>
                              {s.lines.map((ln) => {
                                const item = cartItemByUpc.get(ln.upc);
                                const title = item ? `${item.name}${item.brand ? ` (${item.brand})` : ""}` : ln.upc;
                                const when = formatObservedAt(ln.observed_at ?? null);
                                const src = sourceLabel(ln.source ?? null);
                                const metaParts: string[] = [];
                                if (src) metaParts.push(src);
                                if (when) metaParts.push(when);
                                const meta = metaParts.join("  ");

                                return (
                                  <li key={ln.upc}>
                                    <div>
                                      <b>{title}</b> x{ln.quantity} {item ? qtyLabel(item) : ""}
                                    </div>
                                    {ln.missing ? (
                                      <div style={{ opacity: 0.8 }}>Missing price</div>
                                    ) : (
                                      <div style={{ opacity: 0.9 }}>
                                        ${(ln.extended_price_cents! / 100).toFixed(2)}{" "}
                                        {meta && (
                                          <span style={{ opacity: 0.75 }}>
                                            ({meta})
                                          </span>
                                        )}
                                      </div>
                                    )}
                                  </li>
                                );
                              })}
                            </ul>
                          </details>
                        </li>
                      ))}
                  </ul>

                  <hr />

                  <h4>Submit a missing price (manual)</h4>
                  <div style={{ display: "flex", gap: 8, flexWrap: "wrap", alignItems: "center" }}>
                    <label>
                      Store
                      <select value={submitStoreId} onChange={(e) => setSubmitStoreId(e.target.value)} style={{ marginLeft: 8 }}>
                        {(stores?.stores ?? []).slice(0, 10).map((s) => (
                          <option key={s.id} value={s.id}>
                            {s.name} ({s.id})
                          </option>
                        ))}
                      </select>
                    </label>

                    <label>
                      UPC
                      <input value={submitUpc} onChange={(e) => setSubmitUpc(e.target.value)} style={{ marginLeft: 8, width: 160 }} />
                    </label>

                    <label>
                      Price (cents)
                      <input
                        type="number"
                        value={submitPriceCents}
                        onChange={(e) => setSubmitPriceCents(Number(e.target.value))}
                        style={{ marginLeft: 8, width: 120 }}
                      />
                    </label>

                    <button onClick={onSubmitPrice}>Submit</button>
                  </div>

                  {submitStatus && <p>{submitStatus}</p>}
                </div>
              )}
            </>
          )}
        </section>
      )}

      <footer style={{ marginTop: 24, opacity: 0.75 }}>
        <small>
          Tip: Open your browser devtools Network tab to verify cart calls. If you hit rate limits, wait briefly and try again.
        </small>
      </footer>
    </div>
  );
}
</file>

</files>
